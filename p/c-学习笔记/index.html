<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='目录   1 字符串与指针
  1.1 处理字符与字符串
  1.2 标准C&#43;&#43;的String类
  1.3 指针的概念、指针变量的定义和使用
  1.4 指针与数组
    2 指针与函数
  2.1 参数的传递方式
  2.2 返回指针的函数及指向函数的指针
  2.3 指针数组与指向指针的指针
  2.4 内存的动态分配与释放
  2.5 void 与 const 修饰指针变量
    3 结构体与列表
  3.1 结构体的建立
  3.2 结构体的应用
  3.3 typedef 定义类型名
  3.'><title>C&#43;&#43; 学习笔记</title>

<link rel='canonical' href='https://wpv-chan.github.io/p/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='C&#43;&#43; 学习笔记'>
<meta property='og:description' content='目录   1 字符串与指针
  1.1 处理字符与字符串
  1.2 标准C&#43;&#43;的String类
  1.3 指针的概念、指针变量的定义和使用
  1.4 指针与数组
    2 指针与函数
  2.1 参数的传递方式
  2.2 返回指针的函数及指向函数的指针
  2.3 指针数组与指向指针的指针
  2.4 内存的动态分配与释放
  2.5 void 与 const 修饰指针变量
    3 结构体与列表
  3.1 结构体的建立
  3.2 结构体的应用
  3.3 typedef 定义类型名
  3.'>
<meta property='og:url' content='https://wpv-chan.github.io/p/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'>
<meta property='og:site_name' content='wPv的个人小站'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='C&#43;&#43;' /><meta property='article:published_time' content='2021-07-01T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2021-07-01T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="C&#43;&#43; 学习笔记">
<meta name="twitter:description" content="目录   1 字符串与指针
  1.1 处理字符与字符串
  1.2 标准C&#43;&#43;的String类
  1.3 指针的概念、指针变量的定义和使用
  1.4 指针与数组
    2 指针与函数
  2.1 参数的传递方式
  2.2 返回指针的函数及指向函数的指针
  2.3 指针数组与指向指针的指针
  2.4 内存的动态分配与释放
  2.5 void 与 const 修饰指针变量
    3 结构体与列表
  3.1 结构体的建立
  3.2 结构体的应用
  3.3 typedef 定义类型名
  3.">
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="https://wpv-chan.github.io/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/programming/" >
                Programming
            </a>
        
            <a href="/categories/notes/" >
                Notes
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">C&#43;&#43; 学习笔记</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jul 01, 2021</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    25 min read
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <h2 id="目录">目录</h2>
<ul>
<li>
<p>1 <a class="link" href="#1" >字符串与指针</a></p>
<ul>
<li>
<p>1.1 <a class="link" href="#11-%e5%a4%84%e7%90%86%e5%ad%97%e7%ac%a6%e4%b8%8e%e5%ad%97%e7%ac%a6%e4%b8%b2" >处理字符与字符串</a></p>
</li>
<li>
<p>1.2 <a class="link" href="#12-%e6%a0%87%e5%87%86c%e7%9a%84string%e7%b1%bb" >标准C++的String类</a></p>
</li>
<li>
<p>1.3 <a class="link" href="#13-%e6%8c%87%e9%92%88%e7%9a%84%e6%a6%82%e5%bf%b5%e6%8c%87%e9%92%88%e5%8f%98%e9%87%8f%e7%9a%84%e5%ae%9a%e4%b9%89%e5%92%8c%e4%bd%bf%e7%94%a8" >指针的概念、指针变量的定义和使用</a></p>
</li>
<li>
<p>1.4 <a class="link" href="#14-%e6%8c%87%e9%92%88%e4%b8%8e%e6%95%b0%e7%bb%84" >指针与数组</a></p>
</li>
</ul>
</li>
<li>
<p>2 <a class="link" href="#2" >指针与函数</a></p>
<ul>
<li>
<p>2.1 <a class="link" href="#21-%e5%8f%82%e6%95%b0%e7%9a%84%e4%bc%a0%e9%80%92%e6%96%b9%e5%bc%8f" >参数的传递方式</a></p>
</li>
<li>
<p>2.2 <a class="link" href="#22-%e8%bf%94%e5%9b%9e%e6%8c%87%e9%92%88%e7%9a%84%e5%87%bd%e6%95%b0%e5%8f%8a%e6%8c%87%e5%90%91%e5%87%bd%e6%95%b0%e7%9a%84%e6%8c%87%e9%92%88" >返回指针的函数及指向函数的指针</a></p>
</li>
<li>
<p>2.3 <a class="link" href="#23-%e6%8c%87%e9%92%88%e6%95%b0%e7%bb%84%e4%b8%8e%e6%8c%87%e5%90%91%e6%8c%87%e9%92%88%e7%9a%84%e6%8c%87%e9%92%88" >指针数组与指向指针的指针</a></p>
</li>
<li>
<p>2.4 <a class="link" href="#24-%e5%86%85%e5%ad%98%e7%9a%84%e5%8a%a8%e6%80%81%e5%88%86%e9%85%8d%e4%b8%8e%e9%87%8a%e6%94%be" >内存的动态分配与释放</a></p>
</li>
<li>
<p>2.5 <a class="link" href="#25-void-%e5%92%8c-const-%e4%bf%ae%e9%a5%b0%e6%8c%87%e9%92%88%e5%8f%98%e9%87%8f" >void 与 const 修饰指针变量</a></p>
</li>
</ul>
</li>
<li>
<p>3 <a class="link" href="#3" >结构体与列表</a></p>
<ul>
<li>
<p>3.1 <a class="link" href="#31-%e7%bb%93%e6%9e%84%e4%bd%93%e7%9a%84%e5%bb%ba%e7%ab%8b" >结构体的建立</a></p>
</li>
<li>
<p>3.2 <a class="link" href="#32-%e7%bb%93%e6%9e%84%e4%bd%93%e7%9a%84%e5%ba%94%e7%94%a8" >结构体的应用</a></p>
</li>
<li>
<p>3.3 <a class="link" href="#33-typedef-%e5%ae%9a%e4%b9%89%e7%b1%bb%e5%9e%8b%e5%90%8d" >typedef 定义类型名</a></p>
</li>
<li>
<p>3.4 <a class="link" href="#34-%e9%93%be%e8%a1%a8" >链表</a></p>
</li>
</ul>
</li>
<li>
<p>4 <a class="link" href="#4" >文件操作</a></p>
<ul>
<li>
<p>4.1 <a class="link" href="#41-%e6%96%87%e4%bb%b6%e7%9a%84%e6%89%93%e5%bc%80%e4%b8%8e%e5%85%b3%e9%97%ad" >文件的打开与关闭</a></p>
</li>
<li>
<p>4.2 <a class="link" href="#42-%e6%96%87%e6%9c%ac%e6%96%87%e4%bb%b6%e8%be%93%e5%85%a5%e8%be%93%e5%87%ba" >文本文件输入输出</a></p>
</li>
<li>
<p>4.3 <a class="link" href="#43-%e6%96%87%e4%bb%b6%e5%87%ba%e9%94%99%e6%a3%80%e6%b5%8b%e6%96%b9%e6%b3%95" >文件出错检测方法</a></p>
</li>
<li>
<p>4.4 <a class="link" href="#44-%e5%a4%9a%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c" >多文件操作</a></p>
</li>
<li>
<p>4.5 <a class="link" href="#45-%e6%93%8d%e4%bd%9c%e7%ae%80%e5%8d%95%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%87%e4%bb%b6" >操作简单二进制文件</a></p>
</li>
<li>
<p>4.6 <a class="link" href="#46-%e8%af%bb%e5%86%99%e7%bb%93%e6%9e%84%e4%bd%93%e6%96%87%e4%bb%b6" >读写结构体文件</a></p>
</li>
<li>
<p>4.7 <a class="link" href="#47-%e9%9a%8f%e6%9c%ba%e8%ae%bf%e9%97%ae%e6%96%87%e4%bb%b6" >随机访问文件</a></p>
</li>
</ul>
</li>
<li>
<p>5 <a class="link" href="#5" >类的基础部分</a></p>
<ul>
<li>
<p>5.1 <a class="link" href="#51-%e7%b1%bb%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" >类的基本概念</a></p>
</li>
<li>
<p>5.2 <a class="link" href="#52-%e7%b1%bb%e7%9a%84%e5%a4%9a%e6%96%87%e4%bb%b6%e7%bb%84%e7%bb%87%e6%96%b9%e5%bc%8f" >类的多文件组织方式</a></p>
</li>
<li>
<p>5.3 <a class="link" href="#53-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e4%b8%8e%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0" >构造函数与析构函数</a></p>
</li>
<li>
<p>5.4 <a class="link" href="#54-%e9%87%8d%e8%bd%bd%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0" >重载构造函数</a></p>
</li>
</ul>
</li>
<li>
<p>6 <a class="link" href="#6" >类的高级部分</a></p>
<ul>
<li>
<p>6.1 <a class="link" href="#61-%e9%9d%99%e6%80%81%e6%95%b0%e6%8d%ae%e6%88%90%e5%91%98" >静态数据成员</a></p>
</li>
<li>
<p>6.2 <a class="link" href="#62-%e9%9d%99%e6%80%81%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0" >静态成员函数</a></p>
</li>
<li>
<p>6.3 <a class="link" href="#63-%e5%8f%8b%e5%85%83%e5%87%bd%e6%95%b0" >友元函数</a></p>
</li>
<li>
<p>6.4 <a class="link" href="#64-%e5%af%b9%e8%b1%a1%e7%9a%84%e8%b5%8b%e5%80%bc%e9%97%ae%e9%a2%98" >对象的赋值问题</a></p>
</li>
<li>
<p>6.5 <a class="link" href="#65-%e4%bb%80%e4%b9%88%e6%98%af%e6%8b%b7%e8%b4%9d%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0" >什么是拷贝构造函数</a></p>
</li>
<li>
<p>6.6 <a class="link" href="#66-%e8%b0%83%e7%94%a8%e6%8b%b7%e8%b4%9d%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e7%9a%84%e6%83%85%e5%86%b5" >调用拷贝构造函数的情况</a></p>
</li>
<li>
<p>6.7 <a class="link" href="#67-%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd%e4%b8%8ethis%e6%8c%87%e9%92%88" >赋值运算符重载与this指针</a></p>
</li>
<li>
<p>6.8 <a class="link" href="#68-%e5%8f%8c%e7%9b%ae%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd" >双目运算符重载</a></p>
</li>
<li>
<p>6.9 <a class="link" href="#69-%e5%8d%95%e7%9b%ae%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd" >单目运算符重载</a></p>
</li>
<li>
<p>6.10 <a class="link" href="#610-%e5%85%b3%e7%b3%bb%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd" >关系运算符重载</a></p>
</li>
<li>
<p>6.11 <a class="link" href="#611-%e6%b5%81%e6%93%8d%e4%bd%9c%e7%ac%a6%e9%87%8d%e8%bd%bd" >流操作符重载</a></p>
</li>
<li>
<p>6.12 <a class="link" href="#612-%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd" >类型转换运算符重载</a></p>
</li>
<li>
<p>6.13 <a class="link" href="#613" >下标运算符[]重载</a></p>
</li>
</ul>
</li>
<li>
<p>7 <a class="link" href="#7" >类的继承、多态、虚函数</a></p>
<ul>
<li>
<p>7.1 <a class="link" href="#71-%e7%bb%a7%e6%89%bf" >继承</a></p>
</li>
<li>
<p>7.2 <a class="link" href="#72-%e4%bf%9d%e6%8a%a4%e6%88%90%e5%91%98%e5%92%8c%e7%b1%bb%e7%9a%84%e8%ae%bf%e9%97%ae" >保护成员和类的访问</a></p>
</li>
<li>
<p>7.3 <a class="link" href="#73-%e4%bf%9d%e6%8a%a4%e6%88%90%e5%91%98%e5%92%8c%e7%b1%bb%e7%9a%84%e8%ae%bf%e9%97%ae" >保护成员和类的访问</a></p>
</li>
<li>
<p>7.4 <a class="link" href="#74-%e5%88%9d%e5%a7%8b%e5%8c%96%e5%88%97%e8%a1%a8%e7%9a%84%e4%bd%9c%e7%94%a8" >初始化列表的作用</a></p>
</li>
<li>
<p>7.5 <a class="link" href="#75-%e8%a6%86%e7%9b%96%e5%9f%ba%e7%b1%bb%e7%9a%84%e5%87%bd%e6%95%b0%e6%88%90%e5%91%98" >覆盖基类的函数成员</a></p>
</li>
<li>
<p>7.6 <a class="link" href="#76-%e8%99%9a%e5%87%bd%e6%95%b0%e4%b8%8e%e7%ba%af%e8%99%9a%e5%87%bd%e6%95%b0" >虚函数与纯虚函数</a></p>
</li>
<li>
<p>7.7 <a class="link" href="#77-%e5%a4%9a%e9%87%8d%e7%bb%a7%e6%89%bf%e4%b8%8e%e5%a4%9a%e7%bb%a7%e6%89%bf" >多重继承与多继承</a></p>
</li>
<li>
<p>7.8 <a class="link" href="#78-%e7%b1%bb%e6%a8%a1%e6%9d%bf" >类模板</a></p>
</li>
</ul>
</li>
<li>
<p>8 <a class="link" href="#8" >异常处理</a></p>
</li>
<li>
<p>9  <a class="link" href="#9" >标准模板STL</a></p>
<ul>
<li>
<p>9.1 <a class="link" href="#91-stl-%e6%a6%82%e8%bf%b0" >STL概述</a></p>
</li>
<li>
<p>9.2 <a class="link" href="#92-%e5%ae%b9%e5%99%a8" >容器</a></p>
</li>
<li>
<p>9.3 <a class="link" href="#93-%e8%bf%ad%e4%bb%a3%e5%99%a8" >迭代器</a></p>
</li>
<li>
<p>9.4 <a class="link" href="#94-%e7%ae%97%e6%b3%95" >算法</a></p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="span-id11-字符串与指针span"><!-- raw HTML omitted -->1 字符串与指针<!-- raw HTML omitted --></h2>
<h3 id="11-处理字符与字符串">1.1 处理字符与字符串</h3>
<ul>
<li>
<p>求字符串的长度</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;T&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="sc">&#39;P&#39;</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="sc">&#39;t&#39;</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">};</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
</code></pre></div><p>注意：求字符串长度时，到'\0&rsquo;就会结束</p>
</li>
<li>
<p>字符串的拷贝</p>
<p><strong>方式一</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span><span class="o">*</span> <span class="n">strcpy</span><span class="p">(</span><span class="kt">char</span> <span class="n">s1</span><span class="p">[],</span> <span class="kt">char</span> <span class="n">s2</span><span class="p">[])</span>
</code></pre></div><p>例如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span> <span class="n">src</span><span class="p">[</span><span class="mi">80</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;I am a student&#34;</span><span class="p">};</span>
<span class="kt">char</span> <span class="n">dst</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
</code></pre></div><p>注意：不能使用‘=’号进行直接赋值</p>
<p><strong>方式二</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span><span class="o">*</span> <span class="n">strncpy</span><span class="p">(</span><span class="kt">char</span> <span class="n">s1</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">s2</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</code></pre></div><p>例如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span> <span class="n">src</span><span class="p">[</span><span class="mi">80</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;I am a student&#34;</span><span class="p">};</span>
<span class="kt">char</span> <span class="n">dst</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
<span class="n">strncpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">dst</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</code></pre></div><p>注意：必须加上'\0&rsquo;字符串结束标志</p>
</li>
<li>
<p>字符串的连接</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span><span class="o">*</span> <span class="n">strcat</span><span class="p">(</span><span class="kt">char</span> <span class="n">s1</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">s2</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</code></pre></div><p>将s2字符串连接到s1的尾部，修改了s1，返回的是s1的首地址</p>
<p>注意：s1的空间要足够大</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span> <span class="n">s1</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;You&#34;</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">s2</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;&amp;Me&#34;</span><span class="p">;</span>
<span class="n">strcat</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>
</code></pre></div></li>
<li>
<p>字符串的比较</p>
<p><strong>方式一</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">strcmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">s1</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">s2</span><span class="p">[])</span>
</code></pre></div><p>比较两个字符串的大小，就是从左到右逐个比较对应字符的ASCII码</p>
<p>若s1 &gt; s2，则返回1</p>
<p>若s1 &lt; s2，则返回-1</p>
<p>若s1 = s2，则返回0</p>
<p><strong>方式二</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">strncmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">s1</span><span class="p">[],</span> <span class="k">const</span> <span class="n">s2</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
</code></pre></div><p>比较两个字符串的前len个字符，若字符串s1或者s2的长度小于len，则与strcmp无异</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span> <span class="n">s1</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;China&#34;</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">s2</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;Chinese&#34;</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//输出结果为-1
</span></code></pre></div></li>
<li>
<p>字符串的大小写转换</p>
<p><strong>大写变小写</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span><span class="o">*</span> <span class="n">strlwr</span><span class="p">(</span><span class="kt">char</span> <span class="n">s</span><span class="p">[])</span>
</code></pre></div><p><strong>小写变大写</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span><span class="o">*</span> <span class="n">strupr</span><span class="p">(</span><span class="kt">char</span> <span class="n">s</span><span class="p">[])</span>
</code></pre></div></li>
<li>
<p>字符串的子串查找</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span><span class="o">*</span> <span class="n">strstr</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">s1</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">s2</span><span class="p">[])</span>
</code></pre></div><p>如果字符串s1包含要查找的子串s2，则返回s2在s1中第一次出现的地址，否则直接返回NULL</p>
</li>
<li>
<p>字符串转换为整数的函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">atoi</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[])</span>
</code></pre></div><p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span> <span class="n">s1</span><span class="p">[</span><span class="mi">80</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;789123&#34;</span><span class="p">,</span>
<span class="n">s2</span><span class="p">[</span><span class="mi">80</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;789X123&#34;</span><span class="p">,</span>
<span class="n">s3</span><span class="p">[</span><span class="mi">80</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;X123&#34;</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span><span class="c1">//789123
</span><span class="c1"></span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span><span class="c1">//789
</span><span class="c1"></span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">s3</span><span class="p">);</span><span class="c1">//0
</span></code></pre></div><p>转换成别的数据类型就自己类比啦</p>
<p>atof，atod&hellip;</p>
</li>
<li>
<p>整数转换为字符串</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span><span class="o">*</span> <span class="n">itoa</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">radix</span><span class="p">)</span>
</code></pre></div><p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">s1</span><span class="p">[</span><span class="mi">20</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="n">itoa</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span><span class="c1">//处理3进制
</span><span class="c1"></span><span class="n">itoa</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span><span class="c1">//处理10进制
</span></code></pre></div></li>
</ul>
<h3 id="12-标准c的string类">1.2 标准C++的String类</h3>
<ul>
<li>
<p>包含的头文件</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span>
</code></pre></div></li>
<li>
<p>读取整行</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</code></pre></div><p>注意：要和char类型做区分</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">gets</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">cin</span><span class="p">.</span><span class="n">getline</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</code></pre></div></li>
<li>
<p>string对象的比较
string对象也可以与字符串比较，例如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="n">name1</span> <span class="o">=</span> <span class="s">&#34;John&#34;</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">name2</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;Jone&#34;</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">name1</span> <span class="o">&gt;</span> <span class="n">name2</span><span class="p">);</span><span class="c1">//0
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">name1</span> <span class="o">&lt;</span> <span class="n">name2</span><span class="p">);</span><span class="c1">//1
</span><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">name1</span> <span class="o">==</span> <span class="n">name2</span><span class="p">);</span><span class="c1">//0
</span></code></pre></div></li>
<li>
<p>string对象的初始化</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="n">test1</span><span class="p">;</span>    <span class="c1">//空串
</span><span class="c1"></span><span class="n">string</span> <span class="n">test2</span> <span class="o">=</span> <span class="s">&#34;内容&#34;</span><span class="p">;</span> <span class="c1">//使用=
</span><span class="c1"></span><span class="n">string</span> <span class="nf">test3</span><span class="p">(</span><span class="s">&#34;内容&#34;</span><span class="p">);</span>   <span class="c1">//使用引用字符数组作为参数传给构造函数
</span><span class="c1"></span><span class="n">string</span> <span class="nf">test4</span><span class="p">(</span><span class="n">test2</span><span class="p">);</span> <span class="c1">//用一个string初始化另一而string
</span><span class="c1"></span><span class="n">string</span> <span class="nf">test5</span><span class="p">(</span><span class="n">test2</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span><span class="n">num</span><span class="p">);</span> <span class="c1">//从test2中的第pos个位置开始，拷贝个数为num个字符
</span><span class="c1"></span><span class="n">string</span> <span class="n">test6</span> <span class="o">=</span> <span class="n">test2</span> <span class="o">+</span> <span class="s">&#34;内容&#34;</span> <span class="o">+</span> <span class="n">test3</span> <span class="c1">//混合初始化
</span><span class="c1"></span><span class="n">string</span> <span class="n">test7</span> <span class="o">=</span> <span class="n">test2</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="n">num</span><span class="p">);</span> <span class="c1">//从test2中的第pos个位置开始，拷贝个数为num个字符
</span><span class="c1"></span><span class="n">string</span> <span class="n">test8</span> <span class="o">=</span> <span class="n">test2</span><span class="p">.</span><span class="n">substr</span><span class="p">();</span> <span class="c1">//参数列表为空则会拷贝test2的整个对象（复制test2的简便方法）
</span><span class="c1"></span><span class="n">string</span> <span class="nf">test9</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">ch</span><span class="p">);</span> <span class="c1">//拷贝num个字符型ch到test9
</span></code></pre></div></li>
<li>
<p>string类型常用的操作符</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="o">=</span><span class="p">,</span> <span class="n">assign</span><span class="p">()</span> <span class="c1">//赋以新值
</span><span class="c1"></span><span class="n">swap</span><span class="p">()</span> <span class="c1">//交换两个字符串的内容
</span><span class="c1"></span><span class="o">+=</span><span class="p">,</span> <span class="n">append</span><span class="p">(),</span> <span class="n">push_back</span><span class="p">()</span> <span class="c1">//在尾部添加字符
</span><span class="c1"></span><span class="n">insert</span><span class="p">()</span> <span class="c1">//插入字符
</span><span class="c1"></span><span class="n">erase</span><span class="p">()</span> <span class="c1">//删除字符
</span><span class="c1"></span><span class="n">clear</span><span class="p">()</span> <span class="c1">//删除全部字符
</span><span class="c1"></span><span class="n">replace</span><span class="p">()</span> <span class="c1">//替换字符
</span><span class="c1"></span><span class="o">+</span> <span class="c1">//串联字符串
</span><span class="c1"></span><span class="o">==</span><span class="p">,</span> <span class="o">!=</span><span class="p">,</span> <span class="o">&lt;</span><span class="p">,</span> <span class="o">&lt;=</span><span class="p">,</span> <span class="o">&gt;</span><span class="p">,</span> <span class="o">&gt;=</span><span class="p">,</span> <span class="n">compare</span><span class="p">()</span> <span class="c1">//比较字符串
</span><span class="c1"></span><span class="n">size</span><span class="p">(),</span> <span class="n">length</span><span class="p">()</span> <span class="c1">//返回字符数量
</span><span class="c1"></span><span class="n">max_size</span><span class="p">()</span> <span class="c1">//返回字符的可能最大个数
</span><span class="c1"></span><span class="n">empty</span><span class="p">()</span> <span class="c1">//判断字符串是否为空
</span><span class="c1"></span><span class="n">capacity</span><span class="p">()</span> <span class="c1">//返回重新分配之前的字符容量
</span><span class="c1"></span><span class="n">reserve</span><span class="p">()</span> <span class="c1">//保留一定量内存以容纳一定数量的字符
</span><span class="c1"></span><span class="p">[</span> <span class="p">],</span> <span class="n">at</span><span class="p">()</span> <span class="c1">//存取单一字符
</span><span class="c1"></span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="n">getline</span><span class="p">()</span> <span class="c1">//从stream读取某值
</span><span class="c1"></span><span class="o">&lt;&lt;</span> <span class="c1">//将谋值写入stream
</span><span class="c1"></span><span class="n">copy</span><span class="p">()</span> <span class="c1">//将某值赋值为一个C_string
</span><span class="c1"></span><span class="n">c_str</span><span class="p">()</span> <span class="c1">//将内容以C_string返回
</span><span class="c1"></span><span class="n">data</span><span class="p">()</span> <span class="c1">//将内容以字符数组形式返回
</span><span class="c1"></span><span class="n">substr</span><span class="p">()</span> <span class="c1">//返回某个子字符串
</span><span class="c1"></span><span class="n">find</span><span class="p">()</span> <span class="c1">//查找字符
</span><span class="c1"></span><span class="n">begin</span><span class="p">()</span> <span class="n">end</span><span class="p">()</span> <span class="c1">//提供类似STL的迭代器支持
</span><span class="c1"></span><span class="n">rbegin</span><span class="p">()</span> <span class="n">rend</span><span class="p">()</span> <span class="c1">//逆向迭代器
</span><span class="c1"></span><span class="n">get_allocator</span><span class="p">()</span> <span class="c1">//返回配置器
</span></code></pre></div></li>
</ul>
<h3 id="13-指针的概念指针变量的定义和使用">1.3 指针的概念、指针变量的定义和使用</h3>
<ul>
<li>
<p>指针变量就是存放地址的变量</p>
</li>
<li>
<p>定义指针变量
例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span><span class="o">*</span> <span class="n">pInt</span><span class="p">;</span>
</code></pre></div><p>注意：</p>
<ul>
<li>
<p>指针不知向内存的0号单元，若指针变量值为0或者NULL，则表示空指针</p>
</li>
<li>
<p>地址值与整型数值不同</p>
</li>
<li>
<p>无论何种类型的指针都占用4个字节的内存空间</p>
</li>
</ul>
</li>
<li>
<p>运算符*与&amp;</p>
<p>*：通过指针访问所指变量的数值</p>
<p>&amp;：访问指针内储存的地址</p>
</li>
<li>
<p>引用指针变量</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">90</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>
<span class="n">t</span> <span class="o">=</span> <span class="o">*</span><span class="n">p1</span><span class="p">;</span>
<span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span>
<span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</code></pre></div><p>上述例子实现了p1与p2指向变量的值的交换</p>
</li>
</ul>
<h3 id="14-指针与数组">1.4 指针与数组</h3>
<ul>
<li>
<p>访问数组的方式</p>
<ul>
<li>
<p>下标形式</p>
</li>
<li>
<p>指针形式</p>
</li>
</ul>
</li>
<li>
<p>两种类型数组</p>
<ul>
<li>
<p>全局数组和静态数组：在静态储存区中被创建</p>
</li>
<li>
<p>局部变量：在栈上被创建</p>
</li>
</ul>
</li>
<li>
<p>数据名对应一块内存，其地址与容量在其生命周期内保持不变，只有数组的内容可以改变</p>
</li>
<li>
<p>指针可以指向任意类型的内存块，其特征是“可变”</p>
</li>
<li>
<p>指向一维数组元素的指针</p>
<p>数组名代表该数组的开始地址，数组名即时一个指针常量，例如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="c1">//二者等价
</span></code></pre></div></li>
<li>
<p>指针比较</p>
<p>指向同一个数组的两个指针可以进行比较</p>
<p>逆序存放的代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(</span><span class="n">p1</span> <span class="o">=</span> <span class="n">set</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">set</span><span class="o">+</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">p1</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="p">;</span> <span class="n">p1</span><span class="o">++</span><span class="p">,</span> <span class="n">p2</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">t</span> <span class="o">=</span> <span class="o">*</span><span class="n">p1</span><span class="p">;</span>
  <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="o">*</span><span class="n">p2</span><span class="p">;</span>
  <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>指针变量之间的加法无意义</p>
</li>
<li>
<p>指向二维数组元素的指针</p>
<p>二维数组元素a[i][j]的表示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//表示地址
</span><span class="c1"></span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
<span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">j</span>
<span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="n">j</span>

<span class="c1">//表示数值
</span><span class="c1"></span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
<span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">j</span><span class="p">)</span>
<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="n">j</span><span class="p">)</span>
<span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">i</span><span class="p">))[</span><span class="n">j</span><span class="p">]</span>
</code></pre></div><p>注意：a[0] == a[0][0]</p>
<p>一个通用的二维数组的输出例子</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">Print</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">row</span><span class="o">*</span><span class="n">col</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">col</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">end</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
<hr>
<h2 id="span-id22-指针与函数span"><!-- raw HTML omitted -->2 指针与函数<!-- raw HTML omitted --></h2>
<h3 id="21-参数的传递方式">2.1 参数的传递方式</h3>
<ul>
<li>
<p>基本类型的变量作函数形参</p>
<p>交换变量x与y的值，采用基本类型的变量做函数形参</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
  <span class="n">t</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>这是单向的值传递，形参的变化不会影响实参</p>
</li>
<li>
<p>引用类型作为函数形参</p>
<p>交换变量x与y的值，采用引用类型做函数的形参</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
  <span class="n">t</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>通过定义被调用中的参数为引用类型，将主调函数的值改变</p>
</li>
<li>
<p>指针类型作为函数形参</p>
<p>交换变量x与y的值，采用指针类型做函数形参</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">px</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">py</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
  <span class="n">t</span> <span class="o">=</span> <span class="o">*</span><span class="n">px</span><span class="p">;</span>
  <span class="o">*</span><span class="n">px</span> <span class="o">=</span> <span class="o">*</span><span class="n">py</span><span class="p">;</span>
  <span class="o">*</span><span class="n">py</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>通过定义被调用函数中的参数为指针类型，通过间接存取将主调函数的值改变</p>
<p>注意：指针类型做参数形参的另一种形式是数组名做函数参数</p>
</li>
</ul>
<h3 id="22-返回指针的函数及指向函数的指针">2.2 返回指针的函数及指向函数的指针</h3>
<ul>
<li>
<p>指针型函数</p>
<p>一个函数的返回值是某种数据类型的地址值就是指针型函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span><span class="o">*</span> <span class="nf">function</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>函数指针</p>
<p>函数的入口地址。函数指针变量就是指向函数入口地址的变量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fun</span><span class="p">)(</span><span class="kt">int</span> <span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">?</span><span class="nl">x</span> <span class="p">:</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">fun</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
</code></pre></div><p>用法示例</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">process</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fun</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
<h3 id="23-指针数组与指向指针的指针">2.3 指针数组与指向指针的指针</h3>
<ul>
<li>
<p>指针数组</p>
<p>一个数组里面所有的元素都是指针变量称为指针数组</p>
</li>
<li>
<p>指针数组与数组指针的本质区别就是*与[]的优先级顺序不同</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="n">M</span><span class="p">];</span> <span class="c1">//p是一个数组指针，一个行指针，指向拥有M个元素的一维数组
</span><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">M</span><span class="p">];</span> <span class="c1">//p是一个指针数组，包含有M个指针
</span></code></pre></div></li>
<li>
<p>main函数的参数</p>
<p>在main()函数头部声明的格式为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="c1">//argc表示命令行中字符串的个数
</span><span class="c1">//argv[]指向命令行中的各个字符串
</span></code></pre></div><p>举个栗子，通过命令行参数计算输入数据的和</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">sum</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Command name:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Sum is:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>指向指针的指针</p>
<p>举个栗子</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">pp</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
</code></pre></div></li>
</ul>
<h3 id="24-内存的动态分配与释放">2.4 内存的动态分配与释放</h3>
<ul>
<li>
<p>变量存储空间的分配是系统完成的，不需用户干预</p>
<ul>
<li>
<p>静态变量：编译时分配空间</p>
</li>
<li>
<p>动态变量：系统运动时分配空间</p>
</li>
</ul>
</li>
<li>
<p>程序动态申请空间是由用户在编程时安排的</p>
</li>
<li>
<p>申请多少空间由运行时情况而定，一般通过指针访问空间</p>
</li>
<li>
<p>new用于动态申请储存空间，delete用于释放new申请的存储空间</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//分配单个元素空间
</span><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">iptr</span><span class="p">;</span>
<span class="n">iptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">;</span>
<span class="o">*</span><span class="n">iptr</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
<span class="c1">//也可以这样
</span><span class="c1"></span><span class="n">iptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">25</span><span class="p">);</span>
<span class="k">delete</span> <span class="n">iptr</span><span class="p">;</span>
<span class="c1">//分配一片连续的空间
</span><span class="c1"></span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="k">delete</span> <span class="p">[]</span><span class="n">a</span><span class="p">;</span>
</code></pre></div><p>注意：如果函数的参数是一个指针，不要用指针去申请动态内存，否则会因为申请的空间无法释放而造成内存泄漏</p>
</li>
</ul>
<h3 id="25-void-和-const-修饰指针变量">2.5 void 和 const 修饰指针变量</h3>
<h4 id="251-void修饰指针变量">2.5.1 void修饰指针变量</h4>
<ul>
<li>
<p>void修饰指针</p>
<p>void修饰指针代表是一种不确定类型的指针</p>
</li>
<li>
<p>任何类型的指针都可以直接赋给它，无需类型转换</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span><span class="o">*</span> <span class="n">p1</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p2</span><span class="p">;</span>
<span class="n">p1</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span>
</code></pre></div></li>
<li>
<p>不能对void指针进行算数操作</p>
</li>
</ul>
<h4 id="252-const修饰指针变量">2.5.2 const修饰指针变量</h4>
<ul>
<li>
<p>指向常量的指针</p>
<p>可以改变指针所指的空间，但不可以通过指针改变现在所指的内容</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="c1">//wrong
</span><span class="c1"></span><span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">;</span> <span class="c1">//true
</span></code></pre></div></li>
<li>
<p>常量指针</p>
<p>可以改变指针所指向空间中的内容，但是不能改变指针的指向</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">char</span> <span class="n">stringA</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;abcd&#34;</span><span class="p">,</span> <span class="n">stringB</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;xyz&#34;</span><span class="p">;</span>
<span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">atringA</span><span class="p">;</span>
<span class="n">sp</span> <span class="o">=</span> <span class="n">stringB</span><span class="p">;</span> <span class="c1">//wrong
</span><span class="c1"></span><span class="o">*</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="sc">&#39;t&#39;</span><span class="p">;</span> <span class="c1">//true
</span></code></pre></div></li>
<li>
<p>指向常量的指针常量</p>
<p>既不可以修改指针所指的内容又不可改变指针的指向</p>
</li>
</ul>
<hr>
<h2 id="span-id33-结构体与列表span"><!-- raw HTML omitted -->3 结构体与列表<!-- raw HTML omitted --></h2>
<h3 id="31-结构体的建立">3.1 结构体的建立</h3>
<ul>
<li>
<p>结构体就是通过定义一种数据类型，把不同的数据作为一个整体来处理</p>
</li>
<li>
<p>结构体是一种由程序员创建的抽象数据类型</p>
</li>
<li>
<p>先定义结构体</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span><span class="err">&lt;结构体名称</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="o">&lt;</span><span class="err">成员列表</span><span class="o">&gt;</span>
<span class="p">};</span> <span class="c1">//这里不要忘记了;号
</span></code></pre></div></li>
<li>
<p>再定义变量</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">student</span> <span class="n">John</span><span class="p">,</span> <span class="n">Mary</span><span class="p">;</span>
<span class="k">struct</span> <span class="nc">student</span> <span class="n">John</span><span class="p">,</span> <span class="n">Mary</span><span class="p">;</span>
</code></pre></div></li>
<li>
<p>也可以使用无结构体名构造一次性结构体</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">ID</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">}</span><span class="n">John</span><span class="p">,</span> <span class="n">Mary</span><span class="p">;</span>
</code></pre></div></li>
<li>
<p>初始化结构体类型的变量</p>
<p>用{}括起来的值对结构体变量进行初始化，例如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">student</span> <span class="n">John</span> <span class="o">=</span> <span class="p">{</span><span class="mi">666</span><span class="p">,</span> <span class="s">&#34;Joe&#34;</span><span class="p">};</span>
</code></pre></div><p>用同类型的结构体变量初始化另外一个结构体变量</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">student</span> <span class="n">Merry</span> <span class="o">=</span> <span class="n">John</span><span class="p">;</span>
</code></pre></div></li>
<li>
<p>结构体类型变量及其成员的引用</p>
<p>引用结构体变量的成员</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">John</span><span class="p">.</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">2333</span><span class="p">;</span>
</code></pre></div><p>整体引用结构体变量</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">student</span> <span class="n">John</span> <span class="o">=</span> <span class="p">{...};</span>
<span class="n">student</span> <span class="n">Merry</span><span class="p">;</span>
<span class="n">Merry</span> <span class="o">=</span> <span class="n">John</span><span class="p">;</span>
</code></pre></div><p>注意</p>
<ul>
<li>
<p>不能将结构体作为一个整体进行输入或者输出</p>
</li>
<li>
<p>结构体变量可以用作函数的参数，属于按值传递</p>
</li>
<li>
<p>函数可以返回一个结构体变量</p>
</li>
</ul>
</li>
</ul>
<h3 id="32-结构体的应用">3.2 结构体的应用</h3>
<ul>
<li>
<p>使用结构体变量作为函数参数的效率较低，因为结构体作为形参需要赋值</p>
</li>
<li>
<p>结构体数组与指针</p>
<p>定义结构体数组和初始化</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">student</span> <span class="n">studentList</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="n">student</span> <span class="n">studentList</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{...},</span> <span class="p">{...},</span> <span class="p">{...},</span> <span class="p">{...}};</span>
</code></pre></div><p>使用结构体数组</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//引用元素
</span><span class="c1"></span><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">studentList</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//指针
</span><span class="c1"></span><span class="n">student</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
<span class="n">ps</span> <span class="o">=</span> <span class="n">stud</span><span class="p">;</span>
<span class="n">ps</span><span class="o">++</span><span class="p">;</span>
</code></pre></div></li>
</ul>
<h3 id="33-typedef-定义类型名">3.3 typedef 定义类型名</h3>
<ul>
<li>
<p>语法格式</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="o">&lt;</span><span class="err">原类型名</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="err">自定义的类型名</span><span class="o">&gt;</span>
</code></pre></div><p>栗子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="kt">char</span> <span class="n">NAME</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="n">NAME</span> <span class="n">Joe</span><span class="p">;</span>
<span class="c1">//等价于下面
</span><span class="c1"></span><span class="kt">char</span> <span class="n">Joe</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</code></pre></div></li>
<li>
<p>注意typedef与#define的不同</p>
<ul>
<li>
<p>关键字typedef在编译阶段有效，具有类型检查的功能</p>
</li>
<li>
<p>#define是宏定义，发生在预处理阶段，只会进行简单的字符替换，不做任何检查</p>
</li>
<li>
<p>#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用</p>
</li>
<li>
<p>typedef则具有自己的作用域</p>
</li>
</ul>
</li>
<li>
<p>用typedef定义新类型名</p>
<ul>
<li>
<p>typedef只能用于为已知数据类型名定义新的类型名，并没有增加新的数据类型</p>
</li>
<li>
<p>typedef用于软件移植</p>
<p>比如定义一个叫REAL的浮点类型，在目标平台一上，让它表示最高精度的类型为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">double</span> <span class="n">REAL</span><span class="p">;</span>
</code></pre></div><p>而在不支持long double的第二平台上，改为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="kt">double</span> <span class="n">REAL</span><span class="p">;</span>
</code></pre></div><p>在连double都不支持的平台上，改为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="kt">float</span> <span class="n">REAL</span><span class="p">;</span>
</code></pre></div></li>
</ul>
</li>
</ul>
<h3 id="34-链表">3.4 链表</h3>
<ul>
<li>
<p>链表的引入</p>
<ul>
<li>
<p>数据空间是连续的</p>
</li>
<li>
<p>实际应用无法确定数组的大小</p>
</li>
<li>
<p>定义足够大————空间浪费</p>
</li>
</ul>
</li>
<li>
<p>链表的结构</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="nc">student</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">ID</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
  <span class="n">student</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span> <span class="c1">//链表与结构体的区别
</span><span class="c1"></span><span class="p">};</span>
</code></pre></div></li>
<li>
<p>单向链表</p>
<p>带有头节点的单向链表</p>
<p>不带头节点的单向链表</p>
</li>
<li>
<p>链表的应用示例</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&#34;stdafx.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">node</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span> <span class="n">NODE</span><span class="p">;</span>
<span class="n">NODE</span><span class="o">*</span> <span class="nf">initlist</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">NODE</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NODE</span><span class="p">;</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">NODE</span> <span class="o">*</span><span class="nf">create</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">NODE</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="o">*</span><span class="n">p2</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">initlist</span><span class="p">();</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">a</span><span class="o">!=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NODE</span><span class="p">;</span>
        <span class="n">p1</span> <span class="o">-&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">p2</span> <span class="o">-&gt;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
        <span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">p2</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="n">NODE</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">NODE</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Output list : &#34;</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">NODE</span><span class="o">*</span> <span class="nf">search</span><span class="p">(</span><span class="n">NODE</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">NODE</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">NODE</span> <span class="o">*</span><span class="nf">insert</span><span class="p">(</span><span class="n">NODE</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="n">NODE</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">NODE</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">NODE</span> <span class="o">*</span><span class="nf">create_sort</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">NODE</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">initlist</span><span class="p">();</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NODE</span><span class="p">;</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">NODE</span> <span class="o">*</span><span class="nf">delete_one_node</span><span class="p">(</span><span class="n">NODE</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">NODE</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">-&gt;</span><span class="n">data</span><span class="o">!=</span><span class="n">num</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;NOT found&#34;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">free_list</span><span class="p">(</span><span class="n">NODE</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">NODE</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//return 1;
</span><span class="c1"></span>    <span class="n">NODE</span> <span class="o">*</span><span class="n">st</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span> <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s"> creat a list:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">initlist</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n\t</span><span class="s"> D:Delete I:Insert P: Print S:Search E: Exit</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">c</span><span class="p">;</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">toupper</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="p">{</span>
        <span class="k">case</span><span class="sc">&#39;I&#39;</span><span class="o">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NODE</span><span class="p">;</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;please input a number to be inserted:&#34;</span><span class="p">;</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">st</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
            <span class="n">insert</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">st</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">&#39;D&#39;</span><span class="o">:</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;please input a number to be deleted:&#34;</span><span class="p">;</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">;</span>
            <span class="n">delete_one_node</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">&#39;S&#39;</span><span class="o">:</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;please input a number to be search:&#34;</span><span class="p">;</span>
            <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">search</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;it is in the list. </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;It is not in the list. </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">&#39;P&#39;</span><span class="o">:</span>
          <span class="n">print</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">&#39;E&#39;</span><span class="o">:</span>
            <span class="n">free_list</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
<hr>
<h2 id="span-id44-文件操作span"><!-- raw HTML omitted -->4 文件操作<!-- raw HTML omitted --></h2>
<h3 id="41-文件的打开与关闭">4.1 文件的打开与关闭</h3>
<ul>
<li>
<p>文件流类型</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="cp">#include</span><span class="cpf">&lt;fstream&gt; //文件流头文件</span><span class="cp">
</span><span class="cp"></span>  <span class="n">ifstream</span> <span class="n">a</span><span class="c1">//输入文件流，只读取文件流
</span><span class="c1"></span>  <span class="n">ofstream</span> <span class="n">b</span><span class="c1">//输出文件流，只写入文件流
</span><span class="c1"></span>  <span class="n">fstream</span> <span class="n">c</span><span class="c1">//文件流
</span></code></pre></div></li>
<li>
<p>文件使用过程</p>
<h4 id="打开文件"><strong>打开文件</strong></h4>
<ul>
<li>开启方式</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">ifstream</span> <span class="n">inputFile</span><span class="p">;</span>
<span class="n">inputFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;d:</span><span class="se">\\</span><span class="s">costumer.dat&#34;</span><span class="p">);</span>
<span class="c1">//or
</span><span class="c1"></span><span class="kt">char</span> <span class="n">fileName</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">fileName</span><span class="p">;</span>
<span class="n">inputFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">fileName</span><span class="p">);</span>
</code></pre></div><ul>
<li>使用fstream对象时，第二个参数用于表明文件的打开方式</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">dataFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="err">“</span><span class="n">info</span><span class="p">.</span><span class="n">dat</span><span class="err">”</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">out</span><span class="p">);</span><span class="c1">//只能用于写
</span><span class="c1"></span><span class="n">dataFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="err">“</span><span class="n">info</span><span class="p">.</span><span class="n">dat</span><span class="err">”</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">in</span><span class="p">);</span><span class="c1">//只能用于读
</span><span class="c1"></span><span class="n">dataFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="err">“</span><span class="n">info</span><span class="p">.</span><span class="n">dat</span><span class="err">”</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">noreplace</span><span class="p">);</span><span class="c1">//表明如果文件已存在，则不能打开该文件，如果省略该模式，文件内容将被刷新
</span><span class="c1"></span><span class="n">ios</span><span class="o">::</span><span class="n">nocreate</span><span class="c1">//如果文件不存在，则不能创建
</span><span class="c1"></span><span class="n">ios</span><span class="o">::</span><span class="n">app</span><span class="c1">//追加模式
</span><span class="c1"></span><span class="n">ios</span><span class="o">::</span><span class="n">ate</span><span class="c1">//如果已存在，直接跳转到文件尾部
</span><span class="c1"></span><span class="n">ios</span><span class="o">::</span><span class="n">binary</span><span class="c1">//二进制方式
</span><span class="c1"></span><span class="n">ios</span><span class="o">::</span><span class="n">trune</span><span class="c1">//如果文件存在，删除其内容
</span><span class="c1"></span>
<span class="c1">//上面展示的是先定义对象，再打开文件
</span><span class="c1">//也可以在定义流对象时直接打开文件
</span><span class="c1"></span><span class="n">fstream</span> <span class="n">dataFile</span><span class="p">(</span><span class="s">&#34;name.dat&#34;</span><span class="p">,</span><span class="n">ios</span><span class="o">::</span><span class="n">in</span><span class="o">|</span><span class="n">ios</span><span class="o">::</span><span class="n">out</span><span class="p">);</span>

</code></pre></div><ul>
<li>测试文件是否打开成功</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">ifstream</span> <span class="n">dataFile</span>
<span class="n">dataFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;cust.dat&#34;</span><span class="p">,</span><span class="n">ios</span><span class="o">::</span><span class="n">in</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">dataFile</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;fail to open&#34;</span><span class="p">;</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h4 id="关闭文件"><strong>关闭文件</strong></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">dataFile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
</code></pre></div><ul>
<li>
<p>为何要关闭文件</p>
<p>文件缓冲区是一块小的内存空间</p>
<p>操作系统限制同时打开的文件数量</p>
</li>
</ul>
</li>
</ul>
<h3 id="42-文本文件输入输出">4.2 文本文件输入输出</h3>
<ul>
<li>
<p>使用&laquo;向一个文件写入信息</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">fstream</span> <span class="n">dataFile</span><span class="p">;</span>
  <span class="n">dataFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;demoFile.txt&#34;</span><span class="p">,</span><span class="n">ios</span><span class="o">::</span><span class="n">out</span><span class="p">;</span>

  <span class="n">dataFile</span><span class="o">&lt;&lt;</span><span class="err">”</span><span class="n">Confucius</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">;</span><span class="c1">//写入一个单词，换行
</span><span class="c1"></span>  <span class="n">dataFile</span><span class="o">&lt;&lt;</span><span class="err">”</span><span class="n">Mo</span><span class="o">-</span><span class="n">tse</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">;</span><span class="c1">//写入，换行
</span><span class="c1"></span>
  <span class="n">dataFile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>文件的格式化输出</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">fstream</span> <span class="n">outFile</span><span class="p">(</span><span class="err">“</span><span class="n">number</span><span class="p">.</span><span class="n">txt</span><span class="err">”</span><span class="p">,</span><span class="nl">ios</span><span class="p">:</span><span class="n">out</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">nums</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">1234</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">567</span><span class="p">,</span><span class="mi">34</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">6789</span><span class="p">,</span><span class="mi">124</span><span class="p">,</span><span class="mi">2345</span><span class="p">,</span><span class="mi">89</span><span class="p">};</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">row</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span><span class="n">row</span><span class="o">++</span><span class="p">)</span><span class="c1">//向文件输出三行
</span><span class="c1"></span>  <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">col</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">col</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span><span class="n">col</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
       <span class="n">outFile</span><span class="o">&lt;&lt;</span><span class="n">setw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">nums</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="err">”</span> <span class="err">”</span><span class="p">;</span>
    <span class="p">}</span>
     <span class="n">outFile</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">outFile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>检测文件结束</p>
<p>eof()成员函数：检测文件是否已经结尾，无数可读。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">fstream</span> <span class="n">dataFile</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">81</span><span class="p">];</span>
  <span class="n">dataFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="err">“</span><span class="n">demofile</span><span class="p">.</span><span class="n">txt</span><span class="err">”</span><span class="p">,</span><span class="n">ios</span><span class="o">::</span><span class="n">in</span><span class="p">);</span>
  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">dataFile</span><span class="p">.</span><span class="n">eof</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="n">dataFile</span><span class="o">&gt;&gt;</span><span class="n">name</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">dataFile</span><span class="p">.</span><span class="n">fail</span><span class="p">())</span>
    <span class="k">break</span><span class="p">;</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">name</span><span class="o">&lt;&lt;</span><span class="err">”\</span><span class="n">n</span><span class="err">”</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">dataFile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>采用函数成员读写文件</p>
<p><strong>采用&raquo;读文件的缺陷</strong>：空白字符(空格、跳格、换行、回车)是数据之间的分界符，采用&raquo;操作符进行读取时，会忽略空白字符。</p>
</li>
</ul>
<h4 id="getline成员函数"><strong>getline</strong>成员函数：</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp">  <span class="n">dataFile</span><span class="p">.</span><span class="n">getline</span><span class="p">(</span><span class="n">str</span><span class="p">,</span><span class="mi">81</span><span class="p">,</span><span class="err">’\</span><span class="n">n</span><span class="err">’</span><span class="p">)</span>
</code></pre></div><p><strong>str</strong>: 从文件中读取的数据将存储在该空间中</p>
<p><strong>81</strong>：从文件中最多能读取80个字符</p>
<p><strong>’\n’界符</strong>：如果在读满最大字符之前，遇到了界符，那么将停止读取（注意：该参数可选）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

  <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
  <span class="p">{</span>
    <span class="n">fstream</span> <span class="n">readFile</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">input</span><span class="p">[</span><span class="mi">81</span><span class="p">];</span>

    <span class="n">readFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="err">“</span><span class="n">myTextFile</span><span class="p">.</span><span class="n">txt</span><span class="err">”</span><span class="p">,</span><span class="n">ios</span><span class="o">::</span><span class="n">in</span><span class="p">);</span>

    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">readFile</span><span class="p">.</span><span class="n">eof</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="n">readFile</span><span class="p">.</span><span class="n">getline</span><span class="p">(</span><span class="n">input</span><span class="p">,</span><span class="mi">81</span><span class="p">);</span><span class="c1">//从输入获取最多81个字符进入readFile
</span><span class="c1"></span>      <span class="k">if</span><span class="p">(</span><span class="n">readFile</span><span class="p">.</span><span class="n">fail</span><span class="p">())</span>
      <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">input</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">readFile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div><h4 id="get成员函数">get成员函数</h4>
<ul>
<li>例如：inFile.get(ch);</li>
</ul>
<h4 id="put成员函数">put成员函数</h4>
<ul>
<li>例如：inFile.put(ch);</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">fstream</span> <span class="n">dataFile</span><span class="p">(</span><span class="s">&#34;sentence.txt&#34;</span><span class="p">,</span><span class="n">ios</span><span class="o">::</span><span class="n">out</span><span class="p">);</span>
  <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>

  <span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ch</span><span class="o">==</span><span class="s">&#34;!&#34;</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">dataFile</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">dataFile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="43-文件出错检测方法">4.3 文件出错检测方法</h3>
<ul>
<li>
<p>出错检测</p>
<h4 id="流对象的标志位">流对象的标志位</h4>
<ul>
<li>例如</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">流对象</th>
<th style="text-align:left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ios::eofbit</td>
<td style="text-align:left">当遇到了输入流的尾部时，设置该位</td>
</tr>
<tr>
<td style="text-align:left">ios::failbit</td>
<td style="text-align:left">当操作失败时，设置该位</td>
</tr>
<tr>
<td style="text-align:left">ios::hardfail</td>
<td style="text-align:left">当出现不可恢复错误时，设置该位</td>
</tr>
<tr>
<td style="text-align:left">ios::badbit</td>
<td style="text-align:left">当出现无效操作时，设置该位</td>
</tr>
<tr>
<td style="text-align:left">ios::goodbit</td>
<td style="text-align:left">当上述所有标记都未设置时，设置该位，表明流对象处于正常状态</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>函数检测状态位</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数名称</th>
<th style="text-align:left">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">eof（）</td>
<td style="text-align:left">如果设置了eofbit状态位，该函数将返回true否则返回false</td>
</tr>
<tr>
<td style="text-align:left">fail（）</td>
<td style="text-align:left">如果设置了failbit或hardfail状态位，返回true否则返回false</td>
</tr>
<tr>
<td style="text-align:left">bad ()</td>
<td style="text-align:left">如果设置了badbit状态位，该函数将返回true否则返回false</td>
</tr>
<tr>
<td style="text-align:left">good ()</td>
<td style="text-align:left">如果设置了goodbit状态位，返回true否则返回false</td>
</tr>
<tr>
<td style="text-align:left">clear ()</td>
<td style="text-align:left">调用该函数，将清楚所有状态位</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p><strong>实例</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">showstate</span><span class="p">(</span><span class="n">fstream</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">num</span><span class="o">=</span><span class="mi">10</span><span class="p">;</span>
  <span class="n">fstream</span> <span class="n">testFile</span><span class="p">(</span><span class="s">&#34;stuff.dat&#34;</span><span class="p">,</span><span class="n">ios</span><span class="o">::</span><span class="n">out</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">testFile</span><span class="p">.</span><span class="n">fail</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;打开文件失败!&#34;</span><span class="p">;</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="err">”向文件中写数据</span><span class="o">!</span><span class="err">\</span><span class="n">n</span><span class="err">”</span><span class="p">;</span>

  <span class="n">testFile</span><span class="o">&lt;&lt;</span><span class="n">num</span><span class="p">;</span>
 <span class="n">showState</span><span class="p">(</span><span class="n">testFile</span><span class="p">);</span><span class="c1">//第1次测试
</span><span class="c1"></span> <span class="n">testFile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
 <span class="n">testFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="err">“</span><span class="n">stuff</span><span class="p">.</span><span class="n">dat</span><span class="err">”</span><span class="p">,</span><span class="n">ios</span><span class="o">::</span><span class="n">in</span><span class="p">);</span>
 <span class="k">if</span><span class="p">(</span><span class="n">testFile</span><span class="p">.</span><span class="n">fail</span><span class="p">())</span>
 <span class="p">{</span>
 <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="err">”打开失败\</span><span class="n">n</span><span class="err">”；</span>
 <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
 <span class="p">}</span>
 <span class="n">testFile</span><span class="o">&gt;&gt;</span><span class="n">num</span><span class="p">;</span>
 <span class="n">showState</span><span class="p">(</span><span class="n">testFile</span><span class="p">);</span><span class="c1">//第2次测试
</span><span class="c1"></span> <span class="n">test</span><span class="o">&gt;&gt;</span><span class="n">num</span><span class="p">;</span>
 <span class="n">showState</span><span class="p">(</span><span class="n">testFile</span><span class="p">);</span><span class="c1">//第3次测试
</span><span class="c1"></span> <span class="n">testFile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="p">}</span>

 <span class="kt">void</span> <span class="nf">showState</span><span class="p">(</span><span class="n">fstream</span> <span class="o">&amp;</span><span class="n">file</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="err">”当前文件的状态为：\</span><span class="n">n</span><span class="err">”</span><span class="p">;</span>
 <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="err">”</span><span class="n">eof</span> <span class="nl">bit</span><span class="p">:</span><span class="err">”</span><span class="o">&lt;&lt;</span> <span class="n">file</span><span class="p">.</span><span class="n">eof</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="err">”</span> <span class="err">”</span><span class="p">;</span>
 <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="err">”</span><span class="n">fail</span> <span class="nl">bit</span><span class="p">:</span><span class="err">”</span><span class="o">&lt;&lt;</span><span class="n">file</span><span class="p">.</span><span class="n">fail</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="err">”</span> <span class="err">”</span><span class="p">;</span>
 <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="err">”</span><span class="n">bad</span> <span class="nl">bit</span><span class="p">:</span><span class="err">”</span><span class="o">&lt;&lt;</span><span class="n">file</span><span class="p">.</span><span class="n">bad</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="err">”</span> <span class="err">”</span><span class="p">;</span>
 <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="err">”</span><span class="n">good</span> <span class="nl">bit</span><span class="p">:</span><span class="err">”</span><span class="o">&lt;&lt;</span><span class="n">file</span><span class="p">.</span><span class="n">good</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
 <span class="n">file</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="c1">//清除出错标记位
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h3 id="44-多文件操作">4.4 多文件操作</h3>
<ul>
<li><strong>实例</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span> <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
 <span class="cp">#include</span><span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span><span class="cp"></span> <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
 <span class="p">{</span>
 <span class="n">ifstream</span> <span class="n">inFile</span><span class="p">;</span>
 <span class="n">ofstream</span> <span class="n">outFile</span><span class="p">(</span><span class="err">“</span><span class="n">out</span><span class="p">.</span><span class="n">txt</span><span class="err">”</span><span class="p">);</span>
 <span class="kt">char</span> <span class="n">fileName</span><span class="p">[</span><span class="mi">81</span><span class="p">],</span><span class="n">ch</span><span class="p">,</span><span class="n">ch2</span><span class="p">;</span>
 <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="err">”请输入文件名：”；</span>
 <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">fileName</span><span class="p">;</span>
<span class="n">inFile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">fileName</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">inFile</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="err">”打开失败”</span><span class="o">&lt;&lt;</span><span class="n">fileName</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
   <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
 <span class="p">}</span>
<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">inFile</span><span class="p">.</span><span class="n">eof</span><span class="p">)</span> 
 <span class="p">{</span> 
   <span class="n">inFile</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span> 
  <span class="k">if</span><span class="p">(</span><span class="n">inFile</span><span class="p">.</span><span class="n">fail</span><span class="p">())</span> 
  <span class="k">break</span><span class="p">;</span> 
  <span class="n">ch2</span><span class="o">=</span><span class="n">toupper</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span> 
  <span class="n">outFile</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">ch2</span><span class="p">);</span> 
<span class="p">}</span> 
<span class="n">inFile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span> 
<span class="n">outFile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span> 
 <span class="p">}</span>
</code></pre></div><h3 id="45-操作简单二进制文件">4.5 操作简单二进制文件</h3>
<ul>
<li>
<p><strong>二进制文件</strong></p>
<p>二进制文件是按照在内存中存储的形式存储，不是按照ASCII纯文本方式存储，文件中
存储的数据是非格式化的。</p>
</li>
</ul>
<h4 id="以二进制打开文件">以二进制打开文件</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">file</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;stuff.dat&#34;</span><span class="p">,</span><span class="n">ios</span><span class="o">::</span><span class="n">out</span><span class="o">|</span><span class="n">ios</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span><span class="c1">//缺少binary则以文本打开
</span></code></pre></div><h4 id="二进制文件的读写函数仅如下两个">二进制文件的读写函数（仅如下两个）、</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">file</span><span class="p">.</span><span class="n">read</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
<span class="n">file</span><span class="p">.</span><span class="n">write</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
</code></pre></div><p><strong>实例</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"> <span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
 <span class="p">{</span>
   <span class="n">fstream</span> <span class="n">file</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">};</span>
   <span class="n">file</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;a1.txt&#34;</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">out</span> <span class="o">|</span> <span class="n">ios</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span><span class="c1">// 创建一个二进制文件
</span><span class="c1"></span>   <span class="n">file</span><span class="p">.</span> <span class="n">write</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">,</span><span class="k">sizeof</span> <span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
   <span class="n">file</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
   <span class="n">file</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#34;a1.txt&#34;</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">in</span><span class="o">|</span><span class="n">ios</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span>
   <span class="n">file</span><span class="p">.</span><span class="n">read</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
   <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">count</span><span class="o">++</span><span class="p">)</span>
   <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">setw</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">buffer</span> <span class="p">[</span><span class="n">count</span><span class="p">];</span>
   <span class="n">file</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
   <span class="n">file</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="err">“</span><span class="n">a2</span><span class="p">.</span><span class="n">txt</span><span class="err">”</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">out</span><span class="p">);</span> <span class="c1">// 创建文本文件
</span><span class="c1"></span>   <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
     <span class="n">file</span><span class="o">&lt;&lt;</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
   <span class="n">file</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
 <span class="p">}</span>
</code></pre></div><h3 id="46-读写结构体文件">4.6 读写结构体文件</h3>
<ul>
<li>
<p>读写结构体记录</p>
<p>结构体数据可以采用定长块存储到文件中</p>
<p>因为结构体中可以包含不同类型的数据，所以当打开这种类型文件时，必须以二进制方式
打开</p>
</li>
<li>
<p><strong>实例</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cctype&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">struct</span> <span class="nc">Info</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">21</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">address</span><span class="p">[</span><span class="mi">51</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">phone</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">email</span><span class="p">[</span><span class="mi">51</span><span class="p">];</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">fstream</span> <span class="n">people</span><span class="p">(</span><span class="s">&#34;people.dat&#34;</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">out</span> <span class="o">|</span> <span class="n">ios</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span>
  <span class="n">Info</span> <span class="n">person</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">again</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">people</span><span class="p">.</span><span class="n">fail</span><span class="p">())</span>
  <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;打开文件people.dat出错! </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
      <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">do</span>
  <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;请输入数据:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;姓名:&#34;</span><span class="p">;</span> <span class="n">cin</span><span class="p">.</span><span class="n">getline</span><span class="p">(</span><span class="n">person</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">21</span><span class="p">);</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;年龄:&#34;</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">person</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
      <span class="n">cin</span><span class="p">.</span><span class="n">ignore</span><span class="p">();</span> <span class="c1">// 略过换行符,why?
</span><span class="c1"></span>      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;联系地址:&#34;</span><span class="p">;</span> <span class="n">cin</span><span class="p">.</span><span class="n">getline</span><span class="p">(</span><span class="n">person</span><span class="p">.</span><span class="n">address</span><span class="p">,</span> <span class="mi">51</span><span class="p">);</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;联系电话:&#34;</span><span class="p">;</span> <span class="n">cin</span><span class="p">.</span><span class="n">getline</span><span class="p">(</span><span class="n">person</span><span class="p">.</span><span class="n">phone</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;E-mail:&#34;</span><span class="p">;</span> <span class="n">cin</span><span class="p">.</span><span class="n">getline</span><span class="p">(</span><span class="n">person</span><span class="p">.</span><span class="n">email</span><span class="p">,</span> <span class="mi">51</span><span class="p">);</span>
      <span class="n">people</span><span class="p">.</span><span class="n">write</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">person</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">person</span><span class="p">));</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;还要再输入一个同学的数据吗？&#34;</span><span class="p">;</span>
      <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">again</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">toupper</span><span class="p">(</span><span class="n">again</span><span class="p">)</span> <span class="o">==</span> <span class="sc">&#39;Y&#39;</span><span class="p">);</span>

  <span class="n">people</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>


  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">people</span><span class="p">.</span><span class="n">eof</span><span class="p">())</span>
  <span class="p">{</span>
      <span class="n">people</span><span class="p">.</span><span class="n">read</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">person</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">person</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">people</span><span class="p">.</span><span class="n">fail</span><span class="p">())</span>
      <span class="p">{</span>
          <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">people</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
<h3 id="47-随机访问文件">4.7 随机访问文件</h3>
<ul>
<li>
<p><strong>seekp 和 seekg函数</strong>：</p>
<p>seekp 函数用于输出文件（写，put）</p>
<p>seekg 函数用于输入文件（读，get）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">file</span><span class="p">.</span><span class="n">seekp</span><span class="p">(</span><span class="mi">20L</span><span class="p">,</span><span class="n">ios</span><span class="o">::</span><span class="n">beg</span><span class="p">);</span><span class="c1">//把file对象相对于文件头向后偏移20个字节
</span><span class="c1"></span>
<span class="c1">//文件随机访问模式
</span><span class="c1"></span><span class="n">ios</span><span class="o">::</span><span class="n">beg</span><span class="p">;</span><span class="c1">//从文件头开始计算偏移量
</span><span class="c1"></span><span class="n">ios</span><span class="o">::</span><span class="n">end</span><span class="p">;</span><span class="c1">//从文件尾开始计算偏移量
</span><span class="c1"></span><span class="n">ios</span><span class="o">::</span><span class="n">cur</span><span class="p">;</span><span class="c1">//从当前位置开始计算偏移量
</span></code></pre></div></li>
<li>
<p><strong>seek实例</strong>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;fstream&gt;</span><span class="cp">
</span><span class="cp">#include</span><span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="n">namespcae</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">fstream</span> <span class="n">file</span><span class="p">(</span><span class="s">&#34;digit.txt&#34;</span><span class="p">,</span><span class="n">ios</span><span class="o">::</span><span class="n">in</span><span class="p">);</span><span class="c1">//假设内容是1234567890
</span><span class="c1"></span>  <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span> <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">file</span><span class="p">.</span><span class="n">seekg</span> <span class="p">(</span><span class="mi">1L</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">beg</span> <span class="p">);</span><span class="c1">//调整到2位置
</span><span class="c1"></span>  <span class="n">file</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span> <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">ch</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">file</span><span class="p">.</span><span class="n">seekg</span><span class="p">(</span><span class="o">-</span><span class="mi">3L</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">end</span> <span class="p">);</span><span class="c1">//调整到8位置
</span><span class="c1"></span>  <span class="n">file</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span> <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">ch</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span><span class="c1">//自动后移
</span><span class="c1"></span>  <span class="n">file</span><span class="p">.</span><span class="n">seekg</span><span class="p">(</span><span class="mi">1L</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">cur</span> <span class="p">);</span><span class="c1">//偏移到0
</span><span class="c1"></span>  <span class="n">file</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span> <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">ch</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">file</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p><strong>tellp 和 tellg 函数</strong>:</p>
<p>tellp用于返回写位置</p>
<p>tellg用于返回读位置</p>
</li>
<li>
<p><strong>tell实例</strong>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#include</span> <span class="cpf">&lt;fctream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;cctype&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">fstream</span> <span class="n">file</span><span class="p">(</span><span class="err">“</span><span class="n">digit</span><span class="p">.</span><span class="n">txt</span><span class="err">”</span><span class="p">,</span><span class="n">ios</span><span class="o">::</span><span class="n">in</span><span class="p">);</span><span class="c1">//假设内容是1234567890
</span><span class="c1"></span>  <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">ch</span><span class="p">,</span> <span class="n">again</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ffle</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
   <span class="k">do</span>
  <span class="p">{</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="err">”当前位置为</span><span class="o">:</span><span class="err">”</span><span class="o">&lt;&lt;</span> <span class="n">file</span><span class="p">.</span><span class="n">tellg</span><span class="p">(</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> 
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="err">”输入一个偏移量</span><span class="o">:</span><span class="err">”；</span> 
    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">offset</span><span class="p">;</span> 
    <span class="n">file</span><span class="p">.</span><span class="n">seekg</span> <span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">ios</span><span class="o">::</span><span class="n">beg</span><span class="p">);</span> 
    <span class="n">file</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span> 
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&#34;当前字符是:&#34;</span><span class="o">&lt;&lt;</span> <span class="n">ch</span><span class="p">;</span> 
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="err">”\</span><span class="n">n是否继续</span><span class="o">?</span><span class="err">”；</span> 
    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">again</span><span class="p">;</span> 
  <span class="p">}</span> 
  <span class="k">while</span><span class="p">(</span><span class="n">toupper</span><span class="p">(</span><span class="n">again</span><span class="p">)</span> <span class="o">=</span> <span class="err">‘</span><span class="n">Y</span><span class="err">’</span><span class="p">);</span>
  <span class="n">file</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
<hr>
<h2 id="span-id55-类的基础部分span"><!-- raw HTML omitted -->5 类的基础部分<!-- raw HTML omitted --></h2>
<h3 id="51-类的基本概念">5.1 类的基本概念</h3>
<ul>
<li>
<p><strong>过程化程序设计的缺陷</strong></p>
<p>1、大量的全局变量;</p>
<p>2、程序复杂:程序员难以理解成百，上千的函数;</p>
<p>3、程序难以进行修改和扩充。</p>
<p>4、过程化设计是以过程为中心(函数)。</p>
</li>
</ul>
<p> </p>
<ul>
<li>
<p>类是一种用户自定义类型，声明形式为</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="err">类名</span>
<span class="p">{</span>
  <span class="err">内容</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p><strong>类的内容</strong></p>
<h4 id="数据类型">数据类型</h4>
<p>public：可以在类外通过对象访问</p>
<p>private：只能通过类的成员函数访问</p>
<p>protected：与private类似，但在继承时保持功能</p>
</li>
</ul>
<p> </p>
<ul>
<li>
<p><strong>定义成员函数</strong>:</p>
<h4 id="方式一在类内部定义">方式一、在类内部定义</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Rectengle</span>
<span class="p">{</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="kt">float</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">float</span> <span class="nl">length</span><span class="p">:</span>
    <span class="kt">float</span> <span class="n">area</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">setData</span><span class="p">(</span><span class="kt">float</span> <span class="n">w</span><span class="p">,</span><span class="kt">float</span> <span class="n">l</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">;</span>

      <span class="n">length</span><span class="o">=</span><span class="n">l</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">calcArea</span><span class="p">(</span> <span class="p">);</span>
    <span class="kt">float</span> <span class="nf">getWidth</span><span class="p">(</span> <span class="p">);</span>
    <span class="kt">float</span> <span class="nf">getLength</span><span class="p">(</span> <span class="p">);</span>
    <span class="kt">float</span> <span class="nf">getArea</span><span class="p">(</span> <span class="p">);</span>
<span class="p">};</span>
</code></pre></div><h4 id="方式二在类的外部定义">方式二、在类的外部定义</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Rectengle</span>
<span class="p">{</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="kt">float</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">float</span> <span class="nl">length</span><span class="p">:</span>
    <span class="kt">float</span> <span class="n">area</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">setData</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span><span class="kt">float</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">calcArea</span><span class="p">(</span> <span class="p">);</span>
    <span class="kt">float</span> <span class="nf">getWidth</span><span class="p">(</span> <span class="p">);</span>
    <span class="kt">float</span> <span class="nf">getLength</span><span class="p">(</span> <span class="p">);</span>
    <span class="kt">float</span> <span class="nf">getArea</span><span class="p">(</span> <span class="p">);</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">Rectangle</span><span class="o">::</span><span class="n">setData</span><span class="p">(</span><span class="kt">float</span> <span class="n">w</span><span class="p">,</span> <span class="kt">float</span> <span class="n">l</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">;</span>
  <span class="n">length</span><span class="o">=</span><span class="n">l</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">float</span> <span class="n">Rectangle</span><span class="o">::</span><span class="n">getWidth</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">width</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p><strong>定义对象</strong>:</p>
<h4 id="实例">实例</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Rectangle</span> <span class="n">box</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">wide</span><span class="p">,</span><span class="n">boxLong</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">&#34;请输入长和宽?&#34;</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="s">&#34;请输入长和宽?&#34;</span><span class="p">;</span>
  <span class="n">box</span><span class="p">.</span><span class="n">setData</span><span class="p">(</span><span class="n">wide</span><span class="p">,</span> <span class="n">boxLong</span><span class="p">);</span>
  <span class="n">box</span><span class="p">.</span><span class="n">calcArea</span><span class="p">(</span> <span class="p">);</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;矩形的数据:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;宽: &#34;</span><span class="o">&lt;&lt;</span> <span class="n">box</span><span class="p">.</span><span class="n">getWidth</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;长:&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">box</span><span class="p">.</span><span class="n">getLength</span><span class="p">(</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;面积: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">box</span><span class="p">.</span><span class="n">getArea</span><span class="p">(</span> <span class="p">)</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
<h3 id="52-类的多文件组织方式">5.2 类的多文件组织方式</h3>
<ul>
<li>
<p><strong>组织方式</strong>:</p>
<p>类的定义<strong>存储在头文件</strong>里(类定义文件)</p>
<p>成员<strong>函数定义存储在.cpp文件</strong>(类的实现文件)</p>
<p>应用程序通过#include包含头文件，将类的实现文件和主程序进行联编，从而
生成一个完整的程序</p>
</li>
</ul>
<p> </p>
<h3 id="53-构造函数与析构函数">5.3 构造函数与析构函数</h3>
<ul>
<li>
<p><strong>定义</strong></p>
<p>构造函数：是一个函数成员，在对象创建时，采用给定的值，自动调用该
函数将对象中的数据成员初始化</p>
<p>析构函数：也是一个函数成员，当对象终止时，将自动调用该函数进行
“善后”处理</p>
</li>
</ul>
<p> </p>
<ul>
<li>
<p><strong>构造函数的特点</strong></p>
<p>1.构造函数是与类同名的函数成员;</p>
<p>2.没有返回值类型，也没有void;</p>
<p>3.如果构造函数没有参数，则称为缺省构造函数;</p>
<p>4.如果程序中未声明，则系统自动生成一个缺省形式的构造函数;</p>
<p>5.构造函数允许为内联函数、重载函数、带缺省形参值的函数。</p>
</li>
<li>
<p><strong>构造函数实例</strong>:</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Invoiceltem</span>
<span class="p">{</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">units</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">InvoiceItem</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span><span class="n">desc</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span> <span class="p">[</span><span class="mi">51</span><span class="p">];</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">setInfo</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dscr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">un</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dscr</span><span class="p">);</span>
<span class="n">units</span> <span class="o">=</span> <span class="n">un</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">char</span> <span class="o">*</span><span class="nf">getDesc</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">desc</span><span class="p">;}</span>
<span class="kt">int</span> <span class="nf">getUnits</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nl">units</span><span class="p">:}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="n">Invoiceltem</span> <span class="n">stock</span><span class="p">;</span><span class="c1">//定义时候自动调用
</span><span class="c1"></span><span class="n">stock</span><span class="p">.</span><span class="n">setInfo</span><span class="p">(</span> <span class="s">&#34;鼠标&#34;</span>
<span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">stock</span><span class="p">.</span><span class="n">getDesc</span><span class="p">(</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">stock</span><span class="p">.</span><span class="n">getUnits</span><span class="p">(</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h4 id="指向对象的指针">指向对象的指针</h4>
<ul>
<li>
<p>InvoiceItem *ptr;</p>
</li>
<li>
<p>ptr=new InvoiceItem;//此时调用构造函数</p>
</li>
</ul>
<p> </p>
<ul>
<li>
<p><strong>析构函数的特点</strong></p>
<p>1、析构函数也与类同名，前面多一个波浪号(~)</p>
<p>2、当一个对象终止时，系统自动调用析构函数对此对象做“善后”处理。</p>
<p>3、与构造函数一样，析构函数也没有返回值类型。</p>
<p>4、析构函数无参数。</p>
<p>5、一个类只能有一个析构函数。</p>
<p>6、delete对象时，将调用析构函数。</p>
</li>
<li>
<p><strong>析构函数实例</strong></p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Invoiceltem</span>
<span class="p">{</span> <span class="kt">char</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">units</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">InvoiceItem</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span><span class="n">desc</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span> <span class="p">[</span><span class="mi">51</span><span class="p">];</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="err">“构造函数\</span><span class="n">n</span><span class="p">;}</span> <span class="o">~</span><span class="n">InvoiceItem</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span><span class="k">delete</span> <span class="p">[]</span><span class="n">desc</span><span class="err">；</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="err">“析构函数\</span><span class="n">n</span><span class="err">“</span><span class="p">;}</span>
<span class="c1">//其他函数略
</span><span class="c1"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="n">Invoiceltem</span> <span class="n">stock</span><span class="p">;</span>
<span class="n">stock</span><span class="p">.</span><span class="n">setInfo</span><span class="p">(</span> <span class="s">&#34;鼠标&#34;</span>
<span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">stock</span><span class="p">.</span><span class="n">getDesc</span><span class="p">(</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">stock</span><span class="p">.</span><span class="n">getUnits</span><span class="p">(</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>
<p><strong>带参数构造函数</strong></p>
<p>常常需要把一些数据传递给构造函数，用于初始化对象的成员。</p>
<p>构造函数可以有缺省参数。</p>
<p><strong>实例</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Sale</span>
<span class="p">{</span>
 <span class="kt">float</span> <span class="n">taxRate</span><span class="p">,</span><span class="n">total</span><span class="p">;</span>
 <span class="k">public</span><span class="o">:</span>
 <span class="n">Sale</span><span class="p">(</span><span class="kt">float</span> <span class="n">rate</span><span class="p">)</span>
 <span class="p">{</span>
   <span class="n">taxRate</span><span class="o">=</span><span class="n">rate</span><span class="p">;</span>
 <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
<h3 id="54-重载构造函数">5.4 重载构造函数</h3>
<p>一个类中可以定义多个构造函数</p>
<ul>
<li>
<p><strong>缺省构造函数的表现形式</strong></p>
<p>1、如果类中没有定义构造函数，系统将提供一个无参构造函数(属缺省构造函数),该函数不实现任何功能。如果用户自定义了一个构造函数，那么系统缺省的构造函数将失效。</p>
<p>2、如果类中定义有无参的构造函数，那么该构造函数也是缺省的构造函数。</p>
<p>3、如果类中定义有带参的构造函数，并且所有形参均具有缺省值，那么该构造函数也属于缺省的构造函数。</p>
<p>4、一个类只能有一个缺省构造函数，否则将产生二义性。</p>
<p>出错实例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">A</span><span class="p">;</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>

  <span class="k">public</span><span class="o">:</span>
  <span class="n">A</span><span class="p">(){</span><span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">;}</span>
  <span class="n">A</span><span class="p">(</span><span class="n">aa</span><span class="o">=</span><span class="mi">1</span><span class="p">){</span><span class="n">a</span><span class="o">=</span><span class="n">aa</span><span class="p">;}</span><span class="c1">//两构造函数产生歧义，因为有缺省值，也属于缺省构造函数
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div></li>
</ul>
<p> </p>
<ul>
<li><strong>对象数组</strong>
<h4 id="特点">特点</h4>
<ul>
<li>
<p>创建对象数组时，数组中<strong>每个元素(对象)都将调用构造函数</strong>。</p>
</li>
<li>
<p>如果<strong>没有</strong>为数组元素指定<strong>初始值</strong>，元素便使用缺省值来初始化，即<strong>调用缺省构造函数</strong>。</p>
</li>
<li>
<p>当数组中<strong>每一个对象被删除</strong>时，<strong>都要调用一次析构函数</strong>。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="span-id66-类的高级部分span"><!-- raw HTML omitted -->6 类的高级部分<!-- raw HTML omitted --></h2>
<h3 id="61-静态数据成员">6.1 静态数据成员</h3>
<h4 id="特点-1">特点</h4>
<ul>
<li>
<p>用关键字static声明；<strong>同一个类中的所有对象都共享该变量</strong>；</p>
</li>
<li>
<p>必须<strong>在类外定义和初始化</strong>，用(::)来指明所属的类。</p>
</li>
<li>
<p>静态变量<strong>不依赖于对象而存在</strong>，无论是否定义该类的对象，这种类型的变量都存在。</p>
</li>
<li>
<p>静态数据成员实际上是在类外定义的一个变量，它的生存期和整个程序的生存期一样，在<strong>定义对象之前，静态数据成员就已经存在</strong>。</p>
</li>
<li>
<p>实例</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">StaticDemo</span>
<span class="p">{</span> 
  <span class="k">static</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">putx</span><span class="p">(</span> <span class="kt">int</span> <span class="n">a</span><span class="p">){</span> <span class="n">x</span><span class="o">=</span><span class="n">a</span> <span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">puty</span><span class="p">(</span> <span class="kt">int</span> <span class="n">b</span> <span class="p">){</span> <span class="n">y</span><span class="o">=</span><span class="n">b</span> <span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">getx</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="nf">gety</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">y</span> <span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
<span class="kt">int</span> <span class="n">StaticDemo</span><span class="o">::</span><span class="n">x</span> <span class="p">;</span><span class="c1">// 静态变量x将被StaticDemo类的所有对象共享
</span><span class="c1"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
<span class="n">StaticDemo</span> <span class="n">obj1</span><span class="p">,</span> <span class="n">obj2</span> <span class="p">;</span>
<span class="n">obj1</span><span class="p">.</span><span class="n">putx</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">;</span>
<span class="n">obj1</span><span class="p">.</span><span class="n">puty</span><span class="p">(</span> <span class="mi">10</span><span class="p">)</span> <span class="p">;</span>
<span class="n">obj2</span><span class="p">.</span><span class="n">puty</span><span class="p">(</span><span class="mi">20</span> <span class="p">)</span> <span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;x: &#34;</span><span class="o">&lt;&lt;</span> <span class="n">obj1</span><span class="p">.</span><span class="n">getx</span><span class="p">(</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">obj2</span><span class="p">.</span><span class="n">getx</span><span class="p">(</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;y: &#34;</span><span class="o">&lt;&lt;</span> <span class="n">obj1</span><span class="p">.</span><span class="n">gety</span><span class="p">(</span> <span class="p">)</span> <span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div><h3 id="62-静态成员函数">6.2 静态成员函数</h3>
<h4 id="特点-2">特点</h4>
<ul>
<li>
<p>静态函数成员是类中的一个函数，有<strong>static</strong>修饰。</p>
</li>
<li>
<p>静态函数成员和静态数据成员类似，在<strong>对象生成之前也已经存在</strong>。这就是说在对象
产生之前，静态的函数成员就能访问其它静态成员。</p>
</li>
<li>
<p><strong>类外代码可以使用类名和作用域操作符来调用静态成员函数</strong>。</p>
</li>
<li>
<p>静态成员函数<strong>只能引用属于该类的静态数据成员</strong>或<strong>静态成员函数</strong>。</p>
</li>
<li>
<p>对于静态的函数成员，是通过类名和作用域分辨符调用的。</p>
</li>
<li>
<p>也可以采用对象点的方式调用</p>
</li>
<li>
<p>实例</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Budget</span>
<span class="p">{</span> 
  <span class="k">static</span> <span class="kt">float</span> <span class="n">corpBudget</span><span class="p">;</span><span class="c1">//预算的总额
</span><span class="c1"></span>  <span class="kt">float</span> <span class="n">divBudget</span><span class="p">;</span><span class="c1">//非静态成员
</span><span class="c1"></span><span class="k">public</span><span class="o">:</span>
  <span class="n">Budget</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="n">divBudget</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">addBudget</span><span class="p">(</span> <span class="kt">float</span> <span class="n">b</span><span class="p">)</span>
  <span class="p">{</span> 
    <span class="n">divBudget</span> <span class="o">+=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">corpBudget</span> <span class="o">+=</span> <span class="n">divBudget</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="nf">mainOffice</span><span class="p">(</span> <span class="kt">float</span> <span class="p">);</span><span class="c1">//静态的函数成员
</span><span class="c1"></span>  <span class="kt">float</span> <span class="nf">getDivBudget</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">divBudget</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">float</span> <span class="nf">getCorpBudget</span><span class="p">(</span> <span class="p">){</span> <span class="k">return</span> <span class="n">corpBudget</span><span class="p">;}</span>
<span class="p">};</span>

<span class="kt">float</span> <span class="n">Budget</span><span class="o">::</span><span class="n">corpBudget</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span><span class="c1">//静态数据必须在类的外部进行定义和初始化
</span><span class="c1"></span>
<span class="kt">void</span> <span class="n">Budget</span><span class="o">::</span><span class="n">mainOffice</span><span class="p">(</span><span class="kt">float</span> <span class="n">moffice</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">corpBudget</span> <span class="o">+=</span> <span class="n">moffice</span><span class="p">;</span><span class="c1">//只能使用静态变量或其他静态函数或自己的局部变量
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span> 
<span class="kt">float</span> <span class="n">amount</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">bud</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Enter main office&#39;s budget request: &#34;</span><span class="p">;</span>
<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">amount</span><span class="p">;</span>
<span class="n">Budget</span><span class="o">::</span><span class="n">mainOffice</span><span class="p">(</span><span class="n">amount</span><span class="p">);</span><span class="c1">//调用静态成员函数
</span><span class="c1"></span><span class="n">Budget</span> <span class="n">divisions</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">//定义一个数组，一个总公司有4个子公司
</span><span class="c1"></span><span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Enter the budget for Division &#34;</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="p">;</span>
<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">bud</span><span class="p">;</span>
<span class="n">divisions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addBudget</span><span class="p">(</span><span class="n">bud</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s"> Here are the division budget :</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s"> 子公司&#34;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s"> 预算&#34;</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">divisions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getDivBudget</span><span class="p">(</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="err">&#39;&#39;\</span><span class="n">t</span> <span class="err">公司总预算：&#39;&#39;</span><span class="p">;</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">divisions</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getCorpBudget</span><span class="p">(</span> <span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div><h3 id="63-友元函数">6.3 友元函数</h3>
<h4 id="特点-3">特点</h4>
<ul>
<li>
<p>友元函数<strong>不是类中的函数成员</strong>，但它和类的函数成员一样，<strong>可以访问类中定义的私有成员</strong>。</p>
</li>
<li>
<p>友元函数<strong>可以是一个外部函数</strong>，也<strong>可以是另外一个类的函数成员</strong>。</p>
</li>
<li>
<p>若一个类为另一个类的友元，则此类的<strong>所有成员都能访问对方类的私有成员</strong>。</p>
</li>
</ul>
<h4 id="声明方式">声明方式</h4>
<ul>
<li>
<p>friend 类型 函数名字(数据类型)</p>
</li>
<li>
<p>外部函数作为类的友元实例：</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Point</span>
<span class="p">{</span>
<span class="kt">int</span> <span class="n">xPos</span><span class="p">,</span> <span class="n">yPos</span> <span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">xx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="n">yy</span><span class="o">=</span><span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span> <span class="n">xPos</span><span class="o">=</span><span class="n">xx</span><span class="p">;</span> <span class="n">yPos</span><span class="o">=</span><span class="n">yy</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">GetXPos</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">xPos</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">GetYPos</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">yPos</span><span class="p">;</span> <span class="p">}</span>
<span class="k">friend</span> <span class="kt">double</span> <span class="nf">Distance</span><span class="p">(</span><span class="n">Point</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">Point</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span> <span class="c1">//表面上看是类的成员函数
</span><span class="c1"></span><span class="p">};</span>

<span class="kt">double</span> <span class="nf">Distance</span><span class="p">(</span> <span class="n">Point</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">Point</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span><span class="c1">//注意没有作用域分辨符
</span><span class="c1"></span><span class="p">{</span>
<span class="kt">double</span> <span class="n">dx</span><span class="o">=</span><span class="n">a</span><span class="p">.</span><span class="n">xPos</span><span class="o">-</span><span class="n">b</span><span class="p">.</span><span class="n">xPos</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">dy</span><span class="o">=</span><span class="n">a</span><span class="p">.</span><span class="n">yPos</span><span class="o">-</span><span class="n">b</span><span class="p">.</span><span class="n">yPos</span><span class="p">;</span>
<span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">dx</span><span class="o">+</span><span class="n">dy</span><span class="o">*</span><span class="n">dy</span><span class="p">);</span>
<span class="p">}</span>


</code></pre></div><ul>
<li>类的成员函数作为另外一个类的友元实例</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">A</span><span class="p">;</span><span class="c1">//超前引用
</span><span class="c1"></span><span class="k">class</span> <span class="nc">B</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span> 
  <span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">A</span> <span class="o">&amp;</span><span class="n">o</span><span class="p">);</span> 
<span class="p">}</span> 
<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span> 
  <span class="kt">int</span> <span class="n">data</span><span class="p">;</span> 
  <span class="kt">void</span> <span class="nf">show</span><span class="p">(){</span><span class="n">cout</span> <span class="o">&lt;&lt;</span><span class="n">data</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;}</span> 
  <span class="k">public</span><span class="o">:</span> 
  <span class="k">friend</span> <span class="kt">void</span> <span class="n">B</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">A</span> <span class="o">&amp;</span><span class="n">o</span><span class="p">);</span> <span class="c1">//该函数是类A的友元，须在A后定义
</span><span class="c1"></span><span class="p">}</span>

<span class="kt">void</span> <span class="n">B</span><span class="o">::</span><span class="n">set</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">A</span> <span class="o">&amp;</span><span class="n">o</span><span class="p">)</span> 
<span class="p">{</span> 
  <span class="n">o</span><span class="p">.</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">;</span><span class="n">o</span><span class="p">.</span><span class="n">show</span><span class="p">();</span>
 <span class="p">}</span> 
 
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span> 
  <span class="n">A</span> <span class="n">a</span><span class="p">;</span> 
  <span class="n">B</span> <span class="n">b</span><span class="p">;</span> 
  <span class="n">b</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="n">a</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></div><h3 id="64-对象的赋值问题">6.4 对象的赋值问题</h3>
<ul>
<li>
<p>采用赋值运算符“=”可以将一个对象赋值给另外一个对象，或者采用一个对象初始化另外一个对象</p>
</li>
<li>
<p>在缺省的情况下，这两个操作执行的是对象成员之间的拷贝，也被称为按位拷贝或浅拷贝</p>
</li>
<li>
<p>通过赋值运算符进行对象赋值时，是把一个区域中的内容拷贝过来，覆盖另外一个区域，只影响值的变化，对内存区域没有任何影响</p>
</li>
<li>
<p>赋值和初始化的区别：赋值出现在两个对象都已经存在的情况下，而初始化出现在创建对象时</p>
</li>
<li>
<p>当采用一个对象初始化另外一个对象时，对象成员之间的赋值也是按位拷贝</p>
</li>
<li>
<p>编译器会区分赋值与初始化，赋值的时候调用重载的赋值运算符，初始化的时候调用拷贝构造函数。若类中原来没有，则生成的默认构造函数只会简单地赋值类中的每一个成员</p>
</li>
</ul>
<h3 id="65-什么是拷贝构造函数">6.5 什么是拷贝构造函数</h3>
<ul>
<li>
<p>通常采用按位拷贝操作也能正常赋值，但当类成员变量含有指针时往往不能正常运行</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">PersonInfo</span> <span class="p">{</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">PersonInfo</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">age</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="o">~</span><span class="n">PersonInfo</span><span class="p">()</span> <span class="p">{...}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">PersonInfo</span> <span class="n">person1</span><span class="p">(</span><span class="s">&#34;Jones&#34;</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
  <span class="n">PersonInfo</span> <span class="n">person2</span> <span class="o">=</span> <span class="n">person1</span><span class="p">;</span> <span class="c1">//会导致两个name指向同一个区域
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>解决办法：引入拷贝构造函数，当采用一个对象初始化另一个对象时，将自动调用该函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">PersonInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">PersonInfo</span> <span class="o">&amp;</span><span class="n">Obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">Obj</span><span class="p">.</span><span class="n">name</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">strcpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">Obj</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
  <span class="n">age</span> <span class="o">=</span> <span class="n">Obj</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
<h3 id="66-调用拷贝构造函数的情况">6.6 调用拷贝构造函数的情况</h3>
<ul>
<li>
<p>用对象初始化同类的另一个对象</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">PersonInfo</span> <span class="nf">st2</span><span class="p">(</span><span class="n">st1</span><span class="p">),</span> <span class="n">st3</span> <span class="o">=</span> <span class="n">st1</span><span class="p">;</span>
</code></pre></div></li>
<li>
<p>如果函数的形参时对象，当进行参数传递时将调用拷贝构造函数</p>
</li>
<li>
<p>理解：拷贝构造函数的参数一定是个引用，防止拷贝构造函数被调用后又实例化了一个对象，再次调用了拷贝构造函数，形成无限递归</p>
</li>
<li>
<p>如果函数的返回值是对象，函数执行结束时，将调用拷贝构造函数对无名临时对象初始化</p>
</li>
</ul>
<h3 id="67-赋值运算符重载与this指针">6.7 赋值运算符重载与this指针</h3>
<ul>
<li>
<p>赋值运算符重载</p>
<p>operator= 函数的参数是常引用，优点是:</p>
<ul>
<li>
<p>效率高：采用引用可以防止参数传递时生成对象拷贝，节省了对象初始化和析构的过程。</p>
</li>
<li>
<p>可以防止函数无意间修改对象right的内容。</p>
</li>
<li>
<p>符合赋值运算的常识。</p>
</li>
</ul>
<p>注意：如果对象中有指针成员，采用拷贝构造函数可以解决对象初始化问题，但并不能处理对象赋值。</p>
<p>假设有一个类PersonInfo：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">PersonInfo</span>  <span class="p">{</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>  <span class="kt">int</span> <span class="n">age</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div><p>要进行一个类对另一个类的赋值：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">PersonInfo</span> <span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">;</span><span class="c1">//p1=p2 等价于 p1.operator=(p2)
</span></code></pre></div><p>需要对赋值运算符进行重载：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">PersonInfo</span> <span class="o">&amp;</span><span class="n">right</span><span class="p">)</span>
<span class="p">{</span> 
  <span class="k">delete</span> <span class="p">[</span> <span class="p">]</span> <span class="n">name</span><span class="p">;</span> <span class="c1">//先删除原来的name 
</span><span class="c1"></span>  <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">right</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> 
  <span class="n">strcpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">right</span><span class="p">.</span><span class="n">name</span><span class="p">);</span> 
  <span class="n">age</span> <span class="o">=</span> <span class="n">right</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>this 指针</p>
<p>this是一个隐含的内嵌指针，它指向调用成员函数的当前对象。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">PersonInfo</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">PersonInfo</span> <span class="o">&amp;</span><span class="n">right</span><span class="p">)</span> <span class="c1">//第一个&amp;：返回对象的引用，节省空间，提高效率
</span><span class="c1"></span> <span class="p">{</span> 
  <span class="k">delete</span> <span class="p">[</span> <span class="p">]</span> <span class="n">name</span><span class="p">;</span> 
  <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">right</span><span class="p">.</span><span class="n">name</span><span class="p">)</span><span class="o">+</span> <span class="mi">1</span><span class="p">];</span> 
  <span class="n">strcpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">right</span><span class="p">.</span><span class="n">name</span><span class="p">);</span> 
  <span class="n">age</span> <span class="o">=</span> <span class="n">right</span><span class="p">.</span><span class="n">age</span><span class="p">;</span> 
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> 
 <span class="p">}</span>
</code></pre></div><p>• this指针是以隐含参数的形式传递给非静态的函数成员</p>
<p>• this可用于解决局部变量与成员变量同名的问题</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">PersonInfo</span><span class="p">(</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span> <span class="p">)</span> 
<span class="p">{</span> 
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span> <span class="n">strlen</span><span class="p">(</span> <span class="n">name</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> 
  <span class="n">strcpy</span><span class="p">(</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span> <span class="p">);</span> 
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></li>
</ul>
<h3 id="68-双目运算符重载">6.8 双目运算符重载</h3>
<ul>
<li>
<p>任何一个双目算术运算符 A 被重载以后，当执行二元运算时：</p>
<p>Obj1 A Obj2 完全等价于：Obj1.operator A( Obj2 )</p>
<p>双目算术运算符有+、-、*、/、+= 等</p>
<p>例如：对+运算符进行重载</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">FeetInches</span> 
<span class="p">{</span>  
  <span class="kt">int</span> <span class="n">feet</span><span class="p">,</span> <span class="n">inches</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">FeetInches</span> <span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">FeetInches</span> <span class="o">&amp;</span><span class="p">);</span><span class="c1">//const使得程序无法修改参数，&amp;用于提高效率
</span><span class="c1"></span><span class="p">}</span>
<span class="n">FeetInches</span> <span class="n">FeetInches</span><span class="o">::</span><span class="k">operator</span> <span class="o">+</span> <span class="p">(</span><span class="k">const</span> <span class="n">FeetInches</span> <span class="o">&amp;</span><span class="n">right</span> <span class="p">)</span> 
<span class="p">{</span> 
<span class="n">FeetInches</span> <span class="n">temp</span><span class="p">;</span> 
<span class="n">temp</span><span class="p">.</span><span class="n">inches</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">inches</span> <span class="o">+</span> <span class="n">right</span><span class="p">.</span><span class="n">inches</span><span class="p">;</span>
<span class="n">temp</span><span class="p">.</span><span class="n">feet</span> <span class="o">=</span> <span class="n">feet</span> <span class="o">+</span> <span class="n">right</span><span class="p">.</span><span class="n">feet</span><span class="p">;</span>
<span class="k">return</span> <span class="n">temp</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></li>
</ul>
<h3 id="69-单目运算符重载">6.9 单目运算符重载</h3>
<ul>
<li>
<p>单目算术运算符有 ++、&ndash;、!、~（按位取反）等</p>
<p>例如：对++运算符进行重载</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">FeetInches</span> 
<span class="p">{</span> 
 <span class="kt">int</span> <span class="n">feet</span><span class="p">,</span> <span class="n">inches</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
 <span class="n">FeetInches</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span> <span class="p">);</span><span class="c1">//前置++ 
</span><span class="c1"></span> <span class="n">FeetInches</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="c1">//后置++，其中int为哑元，用作区别标记
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//前置++ 重载
</span><span class="c1"></span><span class="n">FeetInches</span> <span class="n">FeetInches</span><span class="o">::</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
 <span class="o">++</span><span class="n">inches</span><span class="p">;</span> 
 <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> 
<span class="p">}</span>
<span class="c1">// 后置++ 重载
</span><span class="c1"></span><span class="n">FeetInches</span> <span class="n">FeetInches</span><span class="o">::</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
<span class="p">{</span> 
 <span class="n">FeetInches</span> <span class="nf">temp</span><span class="p">(</span><span class="n">feet</span><span class="p">,</span> <span class="n">inches</span><span class="p">);</span> <span class="c1">//先把当前对象的值留下，赋给temp，然后对当前对象进行操作，返回的是当前对象修改之前的数据。
</span><span class="c1"></span> <span class="o">++</span><span class="n">inches</span><span class="p">;</span>
 <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
<h3 id="610-关系运算符重载">6.10 关系运算符重载</h3>
<ul>
<li>
<p>关系算术运算符有 &gt;、&lt;、&lt;=、&gt;=、==、!= 等</p>
<p>重载关系运算符，实现两个对象的比较，其中关系运算符函数要返回一个布尔值（true或false）:</p>
<p>例如：对&gt;运算符进行重载</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">FeetInches</span> 
<span class="p">{</span> 
  <span class="kt">int</span> <span class="n">feet</span><span class="p">,</span> <span class="n">inches</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">FeetInches</span> <span class="o">&amp;</span> <span class="p">);</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="n">FeetInches</span><span class="o">::</span><span class="k">operator</span> <span class="o">&gt;</span> <span class="p">(</span><span class="k">const</span> <span class="n">FeetInches</span> <span class="o">&amp;</span><span class="n">right</span> <span class="p">)</span> 
<span class="p">{</span> 
  <span class="k">if</span> <span class="p">(</span><span class="n">feet</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">.</span><span class="n">feet</span><span class="p">)</span> 
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> 
  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">feet</span><span class="o">==</span><span class="n">right</span><span class="p">.</span><span class="n">feet</span> <span class="o">&amp;&amp;</span> <span class="n">inches</span><span class="o">&gt;</span> <span class="n">right</span><span class="p">.</span><span class="n">inches</span><span class="p">)</span> 
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> 
  <span class="k">else</span> 
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></li>
</ul>
<h3 id="611-流操作符重载">6.11 流操作符重载</h3>
<ul>
<li>
<p>流操作符有 &raquo;、&laquo; 等</p>
<p>由于cout本身不支持类对象的处理，如果要让它同样能打印类对象，必须得重载操作符&laquo;。</p>
<p>注意：如果要为FeetInches类重载流插入符&laquo;，那么必须通过友元函数的形式实现函数重载。因为cout是一个标准的输出流对象，不是类中的对象，不能重载为类中的成员函数。</p>
<p>例如：对&laquo;进行重载如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">FeetInches</span> 
<span class="p">{</span> 
  <span class="kt">int</span> <span class="n">feet</span><span class="p">,</span> <span class="n">inches</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">friend</span> <span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">ostream</span> <span class="o">&amp;</span><span class="p">,</span><span class="n">FeetInches</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">strm</span><span class="p">,</span> <span class="n">FeetInches</span> <span class="o">&amp;</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span> 
  <span class="n">strm</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">feet</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;feet, &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">obj</span><span class="p">.</span><span class="n">inches</span> <span class="o">&lt;&lt;</span><span class="s">&#34; inches&#34;</span><span class="p">;</span> 
  <span class="k">return</span> <span class="n">strm</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div><p>distance1和distance2分别为FeetInches的两个对象：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">distance1</span> <span class="o">&lt;&lt;</span><span class="s">&#34; &#34;</span><span class="o">&lt;&lt;</span> <span class="n">distance2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="p">;</span>
</code></pre></div><p>等价于如下过程：</p>
<p>（1）首先调用重载函数&laquo;，执行cout &laquo; distance1，返回cout对象；</p>
<p>（2）执行cout &laquo; “ ”，返回值是cout对象；</p>
<p>（3）以（1）的方式，执行cout &laquo; distance2；</p>
<p>（4）以（2）的方式，执行表达式中的cout &laquo; endl；</p>
</li>
</ul>
<h3 id="612-类型转换运算符重载">6.12 类型转换运算符重载</h3>
<ul>
<li>
<p>类型转换运算符()</p>
<p>对于一个对象，通过重载类型转换函数，可实现类型转换功能。</p>
<p>例如：对&laquo;进行重载如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">FeetInches</span> 
<span class="p">{</span> 
  <span class="kt">int</span> <span class="n">feet</span><span class="p">,</span> <span class="n">inches</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">operator</span> <span class="kt">float</span><span class="p">(</span> <span class="p">);</span><span class="c1">//函数无返回值类型
</span><span class="c1"></span>  <span class="k">operator</span> <span class="nf">int</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">feet</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
<span class="n">FeetInches</span><span class="o">::</span><span class="k">operator</span> <span class="kt">float</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span> 
  <span class="kt">float</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">feet</span><span class="p">;</span> 
  <span class="n">temp</span> <span class="o">+=</span> <span class="p">(</span><span class="n">inches</span> <span class="o">/</span> <span class="mf">12.0f</span><span class="p">);</span> <span class="k">return</span> <span class="n">temp</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div><p>应用如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span> 
<span class="p">{</span> 
  <span class="n">FeetInches</span>  <span class="n">distance</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
  <span class="kt">int</span>  <span class="n">i</span><span class="p">;</span>
  <span class="kt">float</span>  <span class="n">f</span><span class="p">;</span>

  <span class="n">f</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span>            <span class="c1">//	 f = distance.operator  float( );
</span><span class="c1"></span>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">distance</span><span class="p">;</span>             <span class="c1">//   i = distance.operator  int( );
</span><span class="c1"></span>  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>注意：对象到整形、浮点型的类型转换没有返回值</p>
</li>
</ul>
<h3 id="span-id613613-下标运算符重载span"><!-- raw HTML omitted -->6.13 下标运算符[]重载<!-- raw HTML omitted --></h3>
<ul>
<li>
<p>下标操作符 <input disabled="" type="checkbox"> 通常用于访问数组元素。重载该运算符用于增强操作 C++ 数组的功能。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&#34;John&#34;</span><span class="p">;</span> 
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">//代表的是值 
</span><span class="c1"></span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="sc">&#39;a&#39;</span><span class="p">;</span> <span class="c1">//代表的是空间
</span></code></pre></div><p>下面的实例演示如何重载下标运算符 [ ]：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">IntArray</span>
<span class="p">{</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">aptr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">arraySize</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">IntArray</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="n">arraySize</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
      <span class="n">aptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">s</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arraySize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
          <span class="o">*</span><span class="p">(</span><span class="n">aptr</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//让每一个值都为0
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="o">~</span><span class="n">IntArray</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">aptr</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[</span> <span class="p">](</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">sub</span><span class="p">)</span><span class="c1">//第一个&amp;可以作为空间又可以作为数值，既可以放在赋值运算符的左边又可以放在右边
</span><span class="c1"></span>  <span class="p">{</span>
      <span class="k">return</span> <span class="n">aptr</span><span class="p">[</span><span class="n">sub</span><span class="p">];</span> <span class="c1">//返回一个单元，必须返回一个引用
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">IntArray</span> <span class="n">table</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
      <span class="n">table</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span><span class="c1">//前一个table[]指的是空间，后一个指的是值
</span><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">table</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;store a value in table[11].</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="n">table</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
<h3 id="注意运算符重载不能改变运算符原来要求的参数个数">注意：运算符重载不能改变运算符原来要求的参数个数。</h3>
<hr>
<h2 id="span-id77-类的继承多态虚函数span"><!-- raw HTML omitted -->7 类的继承、多态、虚函数<!-- raw HTML omitted --></h2>
<h3 id="71-继承">7.1 继承</h3>
<ul>
<li>
<p>继承易于扩充现有类以满足新的应用。将已有的类称之为父类，也称基类；将新产生的类称为子类，也称为导出类或派生类。</p>
<p>导出类不做任何改变地继承了基类中的所有变量和函数（构造函数和析构函数除外），并且还可以增加新的数据成员和函数，从而使导出类比基类更为特殊化。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Grade</span> 
<span class="p">{</span> 
  <span class="kt">char</span> <span class="n">letter</span><span class="p">;</span> 
  <span class="kt">float</span> <span class="n">score</span><span class="p">;</span> 
<span class="k">public</span><span class="o">:</span> 
  <span class="kt">void</span> <span class="n">setScore</span><span class="p">(</span><span class="kt">float</span> <span class="n">s</span><span class="p">);</span> 
<span class="p">};</span>
</code></pre></div><p>Test 子类公有继承 Grade父类</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Test</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Grade</span>
<span class="p">{</span> 
  <span class="kt">int</span> <span class="n">numQuestions</span><span class="p">;</span> 
<span class="k">public</span><span class="o">:</span> 
  <span class="n">Test</span><span class="p">(</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="p">);</span>
<span class="p">};</span>
</code></pre></div><p>父类中的公有成员在子类中仍是公有的，它们可以和子类中的公有成员一样被访问。但反过来是错误的，基类对象或基类中的某个函数不能调用子类中的函数。</p>
</li>
</ul>
<h3 id="72-保护成员和类的访问">7.2 保护成员和类的访问</h3>
<ul>
<li>
<p>基类中的保护成员和私有成员比较类似，唯一的区别是：子类不可访问基类中的私有成员，但可访问基类中的保护成员。</p>
<p>在公有继承或保护继承的情况下，子类能访问基类的protected成员。</p>
<p>不同继承方式，基类成员在子类中的表现：</p>
<table>
<thead>
<tr>
<th style="text-align:center">继承方式</th>
<th style="text-align:left">基类成员在子类中的表现</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:left">1．基类的私有成员在子类中不可访问；<!-- raw HTML omitted -->2．基类的保护成员变成了子类中的私有成员；<!-- raw HTML omitted -->3．基类的公有成员变成了子类中的私有成员。</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:left">1．基类的私有成员在子类中不可访问；<!-- raw HTML omitted -->2．基类的保护成员变成了子类中的保护成员；<!-- raw HTML omitted -->3．基类的公有成员变成了子类中的保护成员。</td>
</tr>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:left">1．基类的私有成员在子类中不可访问；<!-- raw HTML omitted -->2．基类的保护成员变成了子类中的保护成员；<!-- raw HTML omitted -->3．基类的公有成员变成了子类中的公有成员。</td>
</tr>
</tbody>
</table>
<p>实例化表现：</p>
<table>
<thead>
<tr>
<th style="text-align:left">基类成员在基类中的表现</th>
<th style="text-align:center">继承方式</th>
<th style="text-align:left">基类成员在子类中的表现</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">private: x<!-- raw HTML omitted -->protected: y<!-- raw HTML omitted -->public: z</td>
<td style="text-align:center">private继承</td>
<td style="text-align:left">x is inaccessible<!-- raw HTML omitted -->private: y<!-- raw HTML omitted -->private: z</td>
</tr>
<tr>
<td style="text-align:left">private: x<!-- raw HTML omitted -->protected: y<!-- raw HTML omitted -->public: z</td>
<td style="text-align:center">protected继承</td>
<td style="text-align:left">x is inaccessible<!-- raw HTML omitted -->protected: y<!-- raw HTML omitted -->protected: z</td>
</tr>
<tr>
<td style="text-align:left">private: x<!-- raw HTML omitted -->protected: y<!-- raw HTML omitted -->public: z</td>
<td style="text-align:center">public继承</td>
<td style="text-align:left">x is inaccessible<!-- raw HTML omitted -->protected: y<!-- raw HTML omitted -->public: z</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>注意：</p>
<p>（1）如果省略了继承修饰符，那么就是私有继承，如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Test</span> <span class="o">:</span> <span class="n">Grade</span>
</code></pre></div><p>（2）不要将继承修饰符与成员的访问修饰符相混淆：</p>
<ul>
<li>继承修饰符是为了限定父类成员在子类中的表现</li>
<li>成员访问修饰符是规定类外语句能否访问类中的成员</li>
</ul>
</li>
</ul>
<h3 id="73-保护成员和类的访问">7.3 保护成员和类的访问</h3>
<ul>
<li>
<p>继承下的构造函数和析构函数</p>
<p>当基类和子类都有构造函数时，如果定义一个子类对象，那么首先要调用基类的构造函数，然后再调用子类的构造函数；</p>
<p>析构函数的调用次序与此相反，即先调用子类的析构函数，然后再调用基类的析构函数。</p>
<p>例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"> <span class="k">class</span> <span class="nc">BaseDemo</span> 
 <span class="p">{</span> 
 <span class="k">public</span><span class="o">:</span> 
   <span class="n">BaseDemo</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;In BaseDemo constructor.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span>
   <span class="o">~</span><span class="n">BaseDemo</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;In BaseDemo destructor.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span> 
 <span class="p">};</span>
 <span class="k">class</span> <span class="nc">DerivedDemo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BaseDemo</span> 
 <span class="p">{</span> 
   <span class="k">public</span><span class="o">:</span>
   <span class="n">DerivedDemo</span><span class="p">(</span> <span class="p">){</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;In DerivedDemo constructor.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span> 
   <span class="o">~</span><span class="n">DerivedDemo</span><span class="p">(</span> <span class="p">)</span>
   <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;In DerivedDemo destructor.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span> 
 <span class="p">};</span>
</code></pre></div></li>
<li>
<p>向父类的构造函数传参数</p>
<p>如果基类和子类都有缺省的构造函数，它们的调用是自动完成的，这是一种隐式调用。</p>
<p>如果基类的构造函数带有参数，那么必须让子类的构造函数显式调用基类的构造函数，并且向基类构造函数传递适当的参数。</p>
<p>实例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Rectangle</span> 
<span class="p">{</span> 
<span class="k">protected</span><span class="o">:</span> 
  <span class="kt">float</span> <span class="n">width</span> <span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">area</span><span class="p">;</span> 
<span class="k">public</span><span class="o">:</span> 
  <span class="n">Rectangle</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="n">width</span> <span class="o">=</span> <span class="n">length</span> <span class="o">=</span> <span class="n">area</span> <span class="o">=</span> <span class="mf">0.0f</span> <span class="p">;</span> <span class="p">}</span> 
  <span class="n">Rectangle</span> <span class="p">(</span> <span class="kt">float</span> <span class="n">w</span><span class="p">,</span> <span class="kt">float</span> <span class="n">l</span> <span class="p">)</span> 
  <span class="p">{</span> 
    <span class="n">width</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span> 
    <span class="n">length</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span> 
    <span class="n">area</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="n">length</span><span class="p">;</span> 
  <span class="p">}</span> 
<span class="p">};</span>
<span class="c1">//子类Cube公有继承基类Rectangle
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Cube</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Rectangle</span> 
<span class="p">{</span> 
<span class="k">protected</span><span class="o">:</span> 
  <span class="kt">float</span> <span class="n">height</span><span class="p">,</span> <span class="n">volume</span><span class="p">;</span> 
<span class="k">public</span><span class="o">:</span> 
  <span class="n">Cube</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="kt">float</span><span class="p">,</span> <span class="kt">float</span><span class="p">);</span> 
<span class="p">};</span>
<span class="c1">//初始化列表
</span><span class="c1"></span><span class="n">Cube</span><span class="o">::</span><span class="n">Cube</span><span class="p">(</span><span class="kt">float</span> <span class="n">w</span><span class="p">,</span> <span class="kt">float</span> <span class="n">l</span><span class="p">,</span> <span class="kt">float</span> <span class="n">h</span><span class="p">)</span> <span class="o">:</span> <span class="n">Rectangle</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> 
<span class="p">{</span> 
  <span class="n">height</span> <span class="o">=</span> <span class="n">h</span> <span class="p">;</span> 
  <span class="n">volume</span> <span class="o">=</span> <span class="n">area</span> <span class="o">*</span> <span class="n">height</span> <span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></li>
</ul>
<h3 id="74-初始化列表的作用">7.4 初始化列表的作用</h3>
<ul>
<li>
<p>初始化列表的作用</p>
<p>如果类之间具有继承关系，子类必须在其初始化列表中调用基类的构造函数。如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Base</span> 
<span class="p">{</span> 
  <span class="n">Base</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">);</span>
<span class="p">};</span> 
<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> 
<span class="p">{</span> 
  <span class="n">Derived</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">:</span> <span class="n">Base</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> 
  <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">}</span> 
<span class="p">};</span>
</code></pre></div></li>
<li>
<p>类中的const常量只能在初始化列表中进行初始化，而不能在函数内用赋值的方式初始化。如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Base</span> 
<span class="p">{</span> 
  <span class="k">const</span> <span class="kt">int</span> <span class="n">SIZE</span> <span class="p">;</span> 
  <span class="n">Base</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="o">:</span> <span class="n">SIZE</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> 
  <span class="p">{</span> <span class="cm">/* … */</span> <span class="p">}</span>
<span class="p">};</span> 

<span class="n">Base</span> <span class="nf">one</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</code></pre></div></li>
<li>
<p>对象类型的成员的初始化放在初始化列表中，则效率较高，反之较低。基本类型变量的初始化可以在初始化列表中，也可在构造函数中，效率上没区别。如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span> 
  <span class="n">Base</span><span class="p">(</span> <span class="p">);</span> 
  <span class="n">Base</span><span class="p">(</span><span class="k">const</span> <span class="n">Base</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">);</span> 
<span class="p">}</span><span class="err">；</span>
<span class="k">class</span> <span class="nc">Derived</span>
<span class="p">{</span>
  <span class="n">Base</span> <span class="n">B_Member</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span> <span class="n">Derived</span><span class="p">(</span><span class="k">const</span> <span class="n">Base</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span> 
<span class="p">};</span>
</code></pre></div><p>构造函数的实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Derived</span><span class="o">::</span><span class="n">Derived</span><span class="p">(</span><span class="k">const</span> <span class="n">Base</span> <span class="o">&amp;</span> <span class="n">b</span> <span class="p">)</span> <span class="o">:</span><span class="n">B_Member</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span> <span class="cm">/* … */</span> <span class="p">}</span>
</code></pre></div><p>也可这样实现，但效率较低：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Derived</span><span class="o">::</span><span class="n">Derived</span><span class="p">(</span><span class="k">const</span> <span class="n">Base</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> 
<span class="p">{</span> <span class="n">B_Member</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></li>
</ul>
<h3 id="75-覆盖基类的函数成员">7.5 覆盖基类的函数成员</h3>
<ul>
<li>
<p>覆盖与重载的区别</p>
<p>重载的特点：</p>
<ul>
<li>
<p>重载表现为有多个函数，它们的 名字相同，但参数不全相同；</p>
</li>
<li>
<p>重载可以出现在同一个类中，也可出现在具有继承关系的父类与子类中；</p>
</li>
<li>
<p>重载也可表现为外部函数的形式。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span> 
  <span class="kt">int</span> <span class="n">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> 
  <span class="p">{</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">x</span><span class="o">&lt;&lt;</span><span class="err">”</span><span class="n">n</span><span class="err">”</span><span class="p">;</span>
  <span class="p">}</span> 
<span class="p">}</span><span class="err">；</span>
<span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> 
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span> 
  <span class="kt">int</span> <span class="n">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span> 
  <span class="p">{</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">&lt;&lt;</span><span class="err">”\</span><span class="n">n</span><span class="err">”</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span> 
<span class="p">};</span>
</code></pre></div></li>
</ul>
<p>覆盖的特点：</p>
<ul>
<li>
<p>覆盖一定出现在具有继承关系的基类和子类之间；</p>
</li>
<li>
<p>覆盖除了要求函数名完全相同，还要求相应的参数个数和类型也完全相同；</p>
</li>
<li>
<p>当进行函数调用时，子类对象所调用 的是子类中定义的函数；</p>
</li>
<li>
<p>覆盖是C++多态性的部分体现。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span> 
<span class="k">public</span><span class="o">:</span> 
  <span class="kt">int</span> <span class="n">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> 
  <span class="p">{</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">x</span><span class="o">&lt;&lt;</span><span class="err">”</span><span class="n">n</span><span class="err">”</span><span class="p">;</span>
  <span class="p">}</span> 
<span class="p">}</span><span class="err">；</span>
<span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> 
<span class="p">{</span> 
<span class="k">public</span><span class="o">:</span> 
  <span class="kt">int</span> <span class="n">fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> 
  <span class="p">{</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">&lt;&lt;</span><span class="err">”\</span><span class="n">n</span><span class="err">”</span><span class="p">;</span>
  <span class="p">}</span> 
<span class="p">};</span>
</code></pre></div></li>
</ul>
</li>
</ul>
<h3 id="76-虚函数与纯虚函数">7.6 虚函数与纯虚函数</h3>
<ul>
<li>
<p>虚函数</p>
<p>函数覆盖体现了一定的多态性。但是，简单的函数覆盖并不能称为真正的多态性。</p>
<p>不支持多态性的语言不是一个正在的OOP语言。</p>
<p>错误实例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">MileDist</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">float</span> <span class="n">miles</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">setDist</span><span class="p">(</span><span class="kt">float</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="n">miles</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">float</span> <span class="nf">getDist</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">miles</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">float</span> <span class="nf">square</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">getDist</span><span class="p">()</span> <span class="o">*</span> <span class="n">getDist</span><span class="p">();</span><span class="c1">//谁的？
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">FeetDist</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MileDist</span> 
<span class="p">{</span> 
<span class="k">protected</span><span class="o">:</span> 
    <span class="kt">float</span> <span class="n">feet</span><span class="p">;</span> 
<span class="k">public</span><span class="o">:</span> 
    <span class="kt">void</span> <span class="n">setDist</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span> 
    <span class="kt">float</span> <span class="nf">getDist</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">feet</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">float</span> <span class="nf">getMiles</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">miles</span><span class="p">;</span> <span class="p">}</span> 
<span class="p">};</span> 
<span class="kt">void</span> <span class="n">FeetDist</span><span class="o">::</span><span class="n">setDist</span><span class="p">(</span><span class="kt">float</span> <span class="n">ft</span><span class="p">)</span>
<span class="p">{</span> 
    <span class="n">feet</span> <span class="o">=</span> <span class="n">ft</span><span class="p">;</span> 
    <span class="n">MileDist</span><span class="o">::</span><span class="n">setDist</span><span class="p">(</span><span class="n">feet</span> <span class="o">/</span> <span class="mi">5280</span><span class="p">);</span> 
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span> 
    <span class="n">FeetDist</span> <span class="n">feet</span><span class="p">;</span> 
    <span class="kt">float</span> <span class="n">ft</span><span class="p">;</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;请输入以英尺为单位的距离：&#34;</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">ft</span><span class="p">;</span> 
    <span class="n">feet</span><span class="p">.</span><span class="n">setDist</span><span class="p">(</span><span class="n">ft</span><span class="p">);</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">feet</span><span class="p">.</span><span class="n">getDist</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; 英尺等于 &#34;</span><span class="p">;</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">feet</span><span class="p">.</span><span class="n">getMiles</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; 英里</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">feet</span><span class="p">.</span><span class="n">getDist</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; 平方等于 &#34;</span><span class="p">;</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">feet</span><span class="p">.</span><span class="n">square</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div><p>错误的原因：
C++编译器在缺省情况下，对函数成员的调用实施的是静态连编（也称静态绑定）。</p>
<p>注意：父类中调用函数是提前确定的，没有根据当前对象类型确定。</p>
<p>OOP: 覆盖和重载不能体现真正的多态性，只有虚函数才是多态性的表现。不支持多态 性的语言，就不能称为OOP。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">MileDist</span> 
<span class="p">{</span> 
<span class="k">protected</span><span class="o">:</span> 
    <span class="kt">float</span> <span class="n">miles</span><span class="p">;</span> 
<span class="k">public</span><span class="o">:</span> 
    <span class="kt">void</span> <span class="n">setDist</span><span class="p">(</span><span class="kt">float</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="n">miles</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span> <span class="p">}</span> 
    <span class="k">virtual</span> <span class="kt">float</span> <span class="nf">getDist</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">miles</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">float</span> <span class="nf">square</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">getDist</span><span class="p">()</span> <span class="o">*</span> <span class="n">getDist</span><span class="p">();</span> <span class="p">}</span> 
<span class="p">};</span>
</code></pre></div></li>
<li>
<p>纯虚函数</p>
<p>纯虚函数是在基类中声明的虚函数，没有函数体，要求继承基类的子类必须覆盖它。</p>
<p>带有纯虚函数的类称为抽象类，不能定义抽象类的对象。</p>
<p>派生类可以根据自己的需要，分别覆盖纯虚函数，从而实现真正意义上的多态性。</p>
<p>格式如下:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">showInfo</span><span class="p">(</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div><p>实例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Student</span> 
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span> 
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">51</span><span class="p">];</span> 
  <span class="kt">int</span> <span class="n">hours</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span> 
  <span class="n">Student</span><span class="p">()</span> <span class="p">{</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">hours</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> 
  <span class="kt">void</span> <span class="nf">setName</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">strcpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="p">}</span> 
  <span class="c1">// Pure virtual function
</span><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">setHours</span><span class="p">(</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">showInfo</span><span class="p">(</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">CsStudent</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Student</span> 
<span class="p">{</span> 
  <span class="kt">int</span> <span class="n">mathHours</span><span class="p">,</span> <span class="n">csHours</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span> 
  <span class="kt">void</span> <span class="n">setMathHours</span><span class="p">(</span><span class="kt">int</span> <span class="n">mh</span><span class="p">)</span> <span class="p">{</span> <span class="n">mathHours</span> <span class="o">=</span> <span class="n">mh</span><span class="p">;</span> <span class="p">}</span> 
  <span class="kt">void</span> <span class="nf">setCsHours</span><span class="p">(</span><span class="kt">int</span> <span class="n">csh</span><span class="p">)</span> <span class="p">{</span> <span class="n">csHours</span> <span class="o">=</span> <span class="n">csh</span><span class="p">;</span> <span class="p">}</span> 
  <span class="kt">void</span> <span class="nf">setHours</span><span class="p">()</span> 
  <span class="p">{</span> <span class="n">hours</span> <span class="o">=</span> <span class="n">mathHours</span> <span class="o">+</span> <span class="n">csHours</span><span class="p">;</span>  <span class="p">}</span> 
  <span class="kt">void</span> <span class="nf">showInfo</span><span class="p">();</span> 
<span class="p">};</span>
<span class="kt">void</span> <span class="n">CsStudent</span><span class="o">::</span><span class="n">showInfo</span><span class="p">()</span> 
<span class="p">{</span> 
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; Name: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s"> Math: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">mathHours</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\t</span><span class="s"> CS : &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">csHours</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n\t</span><span class="s"> Total Hours: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">hours</span><span class="p">;</span> 
<span class="p">}</span> 
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
  <span class="n">CsStudent</span> <span class="n">student1</span><span class="p">;</span> 
  <span class="kt">char</span> <span class="n">chInput</span><span class="p">[</span><span class="mi">51</span><span class="p">];</span> 
  <span class="kt">int</span> <span class="n">intInput</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Enter the following information:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> 
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Name: &#34;</span><span class="p">;</span> 
  <span class="n">cin</span><span class="p">.</span><span class="n">getline</span><span class="p">(</span><span class="n">chInput</span><span class="p">,</span> <span class="mi">51</span><span class="p">);</span> 
  <span class="n">student1</span><span class="p">.</span><span class="n">setName</span><span class="p">(</span><span class="n">chInput</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Number of math hours completed: &#34;</span><span class="p">;</span> 
  <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">intInput</span><span class="p">;</span> 
  <span class="n">student1</span><span class="p">.</span><span class="n">setMathHours</span><span class="p">(</span><span class="n">intInput</span><span class="p">);</span> 
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Number of CS hours completed: &#34;</span><span class="p">;</span> 
  <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">intInput</span><span class="p">;</span> 
  <span class="n">student1</span><span class="p">.</span><span class="n">setCsHours</span><span class="p">(</span><span class="n">intInput</span><span class="p">);</span> 
  <span class="n">student1</span><span class="p">.</span><span class="n">setHours</span><span class="p">();</span> 
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">STUDENT INFORMATION</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> 
  <span class="n">student1</span><span class="p">.</span><span class="n">showInfo</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>关于抽象类和纯虚函数小结</p>
<p>如果一个类包含有纯虚函数，那么它就是抽象类，必须让其它类继承；</p>
<p>基类中的纯虚函数没有代码；</p>
<p>不能定义抽象类的对象，即抽象基类不能实例化；</p>
<p>必须在子类中覆盖基类中的纯虚函数。</p>
</li>
<li>
<p>指向父类的指针</p>
<p>指向基类对象的指针可以指向其子类的对象；</p>
<p>如果子类覆盖了基类中的成员，但通过基类指针所访问的成员仍是基类的成员，而不是子类成员。</p>
<p>实例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Base</span>
<span class="p">{</span> 
<span class="k">public</span><span class="o">:</span> 
  <span class="kt">void</span> <span class="n">show</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;In Base class.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span> 
<span class="p">};</span> 
<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> 
<span class="p">{</span> 
<span class="k">public</span><span class="o">:</span> 
  <span class="kt">void</span> <span class="n">show</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;In Derived class.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span> <span class="p">}</span> 
<span class="p">};</span> 
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span> 
  <span class="n">Base</span><span class="o">*</span> <span class="n">bptr</span><span class="p">;</span> 
  <span class="n">Derived</span> <span class="n">dobject</span><span class="p">;</span> 
  <span class="n">bptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dobject</span><span class="p">;</span> 
  <span class="n">bptr</span><span class="o">-&gt;</span><span class="n">show</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
<h3 id="77-多重继承与多继承">7.7 多重继承与多继承</h3>
<ul>
<li>
<p>多重继承</p>
<p>类C继承类B中所有的成员，包括B从A中继承所得的成员</p>
<p>如：class C-&gt;class B-&gt;class A</p>
</li>
<li>
<p>多继承</p>
<p>如果一个子类具有两个或多个直接父类，那么就称为多继承。</p>
<p>对父类构造函数的调用，是按照继承的顺序进行。</p>
<p>实例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">DateTime</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Date</span><span class="p">,</span> <span class="k">public</span> <span class="n">Time</span><span class="p">{}</span>
</code></pre></div></li>
</ul>
<h3 id="78-类模板">7.8 类模板</h3>
<ul>
<li>
<p>类模板用于创建类属类和抽象数据类型，从而使程序员可以创建一般形式的类，而不必编写处理不同数据类型的类。</p>
<p>类模板的定义和实现必须在同一个文件中，通常是头文件。编译器看到模 板实现时才展开模板。</p>
<p>实例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">template</span>  <span class="o">&lt;</span> <span class="k">class</span>  <span class="nc">T</span> <span class="o">&gt;</span>
<span class="k">class</span>  <span class="nc">FreewillArray</span> 
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">FreewillArray</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span>  <span class="n">aptr</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>  <span class="n">arraySize</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;}</span>
    <span class="n">FreewillArray</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span>	<span class="c1">// 构造函数
</span><span class="c1"></span>    <span class="n">FreewillArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">FreewillArray</span>  <span class="o">&amp;</span> <span class="p">)</span> <span class="p">;</span>  <span class="c1">// 拷贝构造函数
</span><span class="c1"></span>    <span class="o">~</span><span class="n">FreewillArray</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span>    	<span class="c1">// 析构函数
</span><span class="c1"></span>    <span class="kt">int</span>  <span class="nf">size</span><span class="p">(</span> <span class="p">)</span>  <span class="p">{</span>  <span class="k">return</span>  <span class="n">arraySize</span> <span class="p">;</span>  <span class="p">}</span>
    <span class="n">T</span>  <span class="o">&amp;</span><span class="k">operator</span><span class="p">[</span> <span class="p">](</span> <span class="k">const</span>  <span class="kt">int</span>  <span class="o">&amp;</span> <span class="p">)</span> <span class="p">;</span> 	<span class="c1">// 对 [ ] 进行重载
</span><span class="c1"></span><span class="k">private</span><span class="o">:</span>
    <span class="n">T</span>  	<span class="o">*</span><span class="n">aptr</span> <span class="p">;</span>			<span class="c1">// 采用模板参数T替换过去的int 
</span><span class="c1"></span>    <span class="kt">int</span>  	<span class="n">arraySize</span> <span class="p">;</span>
    <span class="kt">void</span>  <span class="nf">memError</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span>    <span class="c1">// 处理内存分配错误
</span><span class="c1"></span>    <span class="kt">void</span>  <span class="nf">subError</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span>    <span class="c1">// 处理下标越界错误
</span><span class="c1"></span><span class="p">}</span> <span class="p">;</span>

  <span class="c1">//  FreewillArray类模板的构造函数。设置数组的大小，并对数组分配内存
</span><span class="c1"></span><span class="k">template</span>  <span class="o">&lt;</span> <span class="k">class</span>  <span class="nc">T</span> <span class="o">&gt;</span>
<span class="n">FreewillArray</span>  <span class="o">&lt;</span> <span class="n">T</span> <span class="o">&gt;::</span><span class="n">FreewillArray</span><span class="p">(</span> <span class="kt">int</span>  <span class="n">s</span> <span class="p">)</span> 
<span class="p">{</span>
    <span class="n">arraySize</span> <span class="o">=</span> <span class="n">s</span> <span class="p">;</span>
    <span class="n">aptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="p">;</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">aptr</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>    
    <span class="n">memError</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span>  <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>  <span class="n">count</span> <span class="o">&lt;</span> <span class="n">arraySize</span> <span class="p">;</span>  <span class="n">count</span><span class="o">++</span> <span class="p">)</span> 
    <span class="o">*</span><span class="p">(</span> <span class="n">aptr</span> <span class="o">+</span> <span class="n">count</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span>

    <span class="c1">//  FreewillArray类模板的拷贝构造函数。
</span><span class="c1"></span><span class="k">template</span>  <span class="o">&lt;</span> <span class="k">class</span>  <span class="nc">T</span> <span class="o">&gt;</span>
<span class="n">FreewillArray</span>  <span class="o">&lt;</span> <span class="n">T</span> <span class="o">&gt;::</span><span class="n">FreewillArray</span><span class="p">(</span> <span class="k">const</span> <span class="n">FreewillArray</span>  <span class="o">&amp;</span><span class="n">obj</span> <span class="p">)</span> 
<span class="p">{</span>
    <span class="n">arraySize</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">arraySize</span> <span class="p">;</span>
    <span class="n">aptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span> <span class="p">[</span><span class="n">arraySize</span><span class="p">]</span> <span class="p">;</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">aptr</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>    
    <span class="n">memError</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="kt">int</span>  <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>  <span class="n">count</span> <span class="o">&lt;</span> <span class="n">arraySize</span> <span class="p">;</span>  <span class="n">count</span><span class="o">++</span> <span class="p">)</span> 
    <span class="o">*</span><span class="p">(</span> <span class="n">aptr</span> <span class="o">+</span> <span class="n">count</span> <span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span> <span class="n">obj</span><span class="p">.</span><span class="n">aptr</span> <span class="o">+</span> <span class="n">count</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>

    <span class="c1">//  FreewillArray类模板的析构函数。
</span><span class="c1"></span><span class="k">template</span>  <span class="o">&lt;</span> <span class="k">class</span>  <span class="nc">T</span> <span class="o">&gt;</span>
<span class="n">FreewillArray</span>  <span class="o">&lt;</span> <span class="n">T</span> <span class="o">&gt;::~</span><span class="n">FreewillArray</span><span class="p">(</span> <span class="p">)</span> 
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">arraySize</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> 
    <span class="k">delete</span> <span class="p">[</span> <span class="p">]</span> <span class="n">aptr</span> <span class="p">;</span>
<span class="p">}</span>

    <span class="c1">//  memError 函数。当内存分配出错时，显示错误信息，并终止程序
</span><span class="c1"></span><span class="k">template</span>  <span class="o">&lt;</span> <span class="k">class</span>  <span class="nc">T</span> <span class="o">&gt;</span>
<span class="kt">void</span>  <span class="n">FreewillArray</span>  <span class="o">&lt;</span> <span class="n">T</span> <span class="o">&gt;::</span><span class="n">memError</span><span class="p">(</span> <span class="p">)</span> 
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;错误：无足够的内存空间.</span><span class="se">\n</span><span class="s">&#34;</span> <span class="p">;</span>
    <span class="n">exit</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>

    <span class="c1">//  subError 函数成员。当数组下标越界时，显示错误信息，并终止程序
</span><span class="c1"></span><span class="k">template</span>  <span class="o">&lt;</span> <span class="k">class</span>  <span class="nc">T</span> <span class="o">&gt;</span>
<span class="kt">void</span>  <span class="n">FreewillArray</span>  <span class="o">&lt;</span> <span class="n">T</span> <span class="o">&gt;::</span><span class="n">subError</span><span class="p">(</span> <span class="p">)</span> 
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;错误：数组下标越界</span><span class="se">\n</span><span class="s">&#34;</span> <span class="p">;</span>
    <span class="n">exit</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>

    <span class="c1">//  重载运算符[ ]，函数的参数是一个下标，在正常情况下，函数返回
</span><span class="c1"></span>    <span class="c1">// 下标指定的数组元素的引用，否则调用subError函数终止程序。
</span><span class="c1"></span><span class="k">template</span>  <span class="o">&lt;</span> <span class="k">class</span>  <span class="nc">T</span> <span class="o">&gt;</span>
<span class="n">T</span>  <span class="o">&amp;</span><span class="n">FreewillArray</span>  <span class="o">&lt;</span> <span class="n">T</span> <span class="o">&gt;::</span><span class="k">operator</span><span class="p">[</span> <span class="p">](</span> <span class="k">const</span>  <span class="kt">int</span>  <span class="o">&amp;</span><span class="n">sub</span> <span class="p">)</span> 
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">sub</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">sub</span> <span class="o">&gt;</span> <span class="n">arraySize</span> <span class="p">)</span>
    <span class="n">subError</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span>
    <span class="k">return</span>  <span class="n">aptr</span><span class="p">[</span><span class="n">sub</span><span class="p">]</span> <span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span>  <span class="nf">main</span><span class="p">(</span> <span class="p">)</span> 
<span class="p">{</span>   
    <span class="n">FreewillArray</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">intTable</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>    <span class="c1">//intTable和floatTable都是对象
</span><span class="c1"></span>    <span class="n">FreewillArray</span> <span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">floatTable</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>  <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">;</span>  <span class="n">x</span><span class="o">++</span> <span class="p">)</span> 	    <span class="c1">// 在数组中存储值
</span><span class="c1"></span>    <span class="p">{</span>
    <span class="n">intTable</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="p">;</span>
    <span class="n">floatTable</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 显示数组中的值
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;intTable中的值是：</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>  <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">;</span>  <span class="n">x</span><span class="o">++</span> <span class="p">)</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">intTable</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;  &#34;</span> <span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;floatTable中的值是：</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>  <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">;</span>  <span class="n">x</span><span class="o">++</span> <span class="p">)</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">floatTable</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;  &#34;</span> <span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="p">;</span>

    <span class="c1">// 对数组元素采用内嵌+操作
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>  <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">;</span>  <span class="n">x</span><span class="o">++</span> <span class="p">)</span> 	
    <span class="p">{</span>
    <span class="n">intTable</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">intTable</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">;</span>
    <span class="n">floatTable</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">floatTable</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.5f</span> <span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 显示数组中的值
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;intTable中的值是：</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>  <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">;</span>  <span class="n">x</span><span class="o">++</span> <span class="p">)</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">intTable</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;  &#34;</span> <span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;floatTable中的值是：</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>  <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">;</span>  <span class="n">x</span><span class="o">++</span> <span class="p">)</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">floatTable</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;  &#34;</span> <span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="p">;</span>

    <span class="c1">// 对数组元素采用内嵌++操作
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>  <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">;</span>  <span class="n">x</span><span class="o">++</span> <span class="p">)</span> 	
    <span class="p">{</span>
    <span class="n">intTable</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">++</span> <span class="p">;</span>
    <span class="n">floatTable</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">++</span> <span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 显示数组中的值
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;intTable中的值是：</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>  <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">;</span>  <span class="n">x</span><span class="o">++</span> <span class="p">)</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">intTable</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;  &#34;</span> <span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;floatTable中的值是：</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="p">;</span>
    <span class="k">for</span><span class="p">(</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>  <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="p">;</span>  <span class="n">x</span><span class="o">++</span> <span class="p">)</span> 
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">floatTable</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;  &#34;</span> <span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><pre tabindex="0"><code>
</code></pre></li>
</ul>
<hr>
<h2 id="span-id88-异常处理span"><!-- raw HTML omitted -->8 异常处理<!-- raw HTML omitted --></h2>
<ul>
<li>
<p>基本异常</p>
<p>异常是在程序执行期间的突发性事件</p>
<p>异常与错误不同，错误可以通过编译系统处理</p>
</li>
<li>
<p>抛出异常</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">float</span> <span class="nf">divide</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">,</span> <span class="kt">int</span> <span class="n">div</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">div</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="s">&#34;ERROR: divided by zero&#34;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">float</span><span class="p">(</span><span class="n">number</span><span class="p">)</span> <span class="o">/</span> <span class="n">div</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>处理异常</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">try</span> <span class="p">{</span>
  <span class="o">&lt;</span><span class="err">可能出现异常的代码</span><span class="o">&gt;</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">exception</span> <span class="n">param1</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">&lt;</span><span class="err">处理异常类型</span><span class="mi">1</span><span class="err">的代码</span><span class="o">&gt;</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">exception</span> <span class="n">param2</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">&lt;</span><span class="err">处理异常类型</span><span class="mi">2</span><span class="err">的代码</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>异常处理失败的原因</p>
<p>try语句块中世纪产生的异常，与catch语句圆括号指定要捕捉的异常类型不匹配</p>
<p>try语句的范围太小，在try语句之前就已经产生了异常，那么后面的try语句块将不再执行</p>
</li>
<li>
<p>基于对象的异常处理</p>
<p>C++除了支持基本类型的异常处理外，还支持面向对象的异常处理</p>
<p>C++在处理多种类型的异常时，要求这些异常对象必须属于不同类型，并且对于每种类型的异常都要编写一段对应的catch代码</p>
<p>栗子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">IntRange</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">input</span><span class="p">,</span> <span class="n">lowest</span><span class="p">,</span> <span class="n">highest</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">class</span> <span class="nc">tooLow</span> <span class="p">{};</span>
  <span class="k">class</span> <span class="nc">tooHigh</span> <span class="p">{};</span>
  <span class="n">InRange</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">lowest</span> <span class="o">=</span> <span class="n">lowest</span><span class="p">;</span>
    <span class="n">highest</span> <span class="o">=</span> <span class="n">highest</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="nf">getInput</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">input</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">input</span> <span class="o">&lt;</span> <span class="n">lowest</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="n">tooLow</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">input</span> <span class="o">&gt;</span> <span class="n">highest</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="n">tooHigh</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">input</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">InRange</span> <span class="n">range</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">uerValue</span><span class="p">;</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="n">userValue</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">getInput</span><span class="p">();</span>
  <span class="p">}</span> 
  <span class="k">catch</span><span class="p">(</span><span class="n">IntRange</span><span class="o">::</span><span class="n">tooLow</span><span class="p">)</span> <span class="p">{...}</span>
  <span class="k">catch</span><span class="p">(</span><span class="n">IntRange</span><span class="o">::</span><span class="n">tooHigh</span><span class="p">)</span> <span class="p">{...}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>还可以通过异常对象将异常信息传递给异常处理者</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">IntRange2</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">input</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">class</span> <span class="nc">OutOfRange</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span> 
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">OutOfRange</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">value</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>     
  <span class="p">};</span>
  <span class="kt">int</span> <span class="nf">getInput</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">input</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(...)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="n">OutOfRange</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">iuput</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">IntRange2</span> <span class="n">range</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">userValue</span><span class="p">;</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="n">userValue</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">getInput</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">catch</span> <span class="p">(</span><span class="n">IntRange2</span><span class="o">::</span><span class="n">OutOfRange</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>注意事项</p>
<ul>
<li>
<p>一旦程序抛出异常，即使在异常处理以后，程序也不能回到原来的抛出点继续执行</p>
</li>
<li>
<p>一旦程序抛出异常，执行throw语句的函数将立即停止运行</p>
</li>
<li>
<p>对象的函数成员抛出了异常，那么将立即对该对象调用析构函数</p>
</li>
<li>
<p>在try块中创建了对象，并且这些对象还未来得及析构，那么将对这些对象立即调用析构函数</p>
</li>
</ul>
</li>
<li>
<p>再次抛出异常</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">try</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="n">exception</span> <span class="n">param1</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">throw</span><span class="p">;</span> <span class="c1">//经过处理后再次抛出异常交给函数调用链的上层函数处理
</span><span class="c1"></span><span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="n">exception</span> <span class="n">param2</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></li>
</ul>
<hr>
<h2 id="span-id99-标准模板stlspan"><!-- raw HTML omitted -->9 标准模板STL<!-- raw HTML omitted --></h2>
<h3 id="91-stl-概述">9.1 STL 概述</h3>
<ul>
<li>
<p>标准模板库：常用数据结构和算法的模板的集合</p>
</li>
<li>
<p>容器：可以容纳各种数据类型的通用数据结构，是类模板</p>
</li>
<li>
<p>迭代器：可以用于依次存取容器中的元素，类似于指针</p>
</li>
<li>
<p>算法：用来操作容器中的元素的函数模板</p>
</li>
</ul>
<h3 id="92-容器">9.2 容器</h3>
<ul>
<li>
<p>顺序容器</p>
<ul>
<li>
<p>vector</p>
<p>动态数组。元素在内存连续存放，随机储存任何元素都能在常数时间完成</p>
</li>
<li>
<p>deque</p>
<p>双向队列，元素在内训连续存放，随机存取任何元素都能在常数时间完成（次于vector）</p>
</li>
<li>
<p>list</p>
<p>双向链表，元素在内存不能连续存放，在任何位置增删元素都能在常数时间完成，不支持随机存取</p>
</li>
<li>
<p>array</p>
</li>
<li>
<p>forward_list （C++ 11中介绍）</p>
</li>
</ul>
</li>
<li>
<p>关联容器</p>
<ul>
<li>
<p>元素是排序的，插入任何元素，都应按相应的排列规则来确定位置，因此具有较好的性能</p>
</li>
<li>
<p>通常以平衡二叉树的方式实现，插入于检索的时间都是O(log(N))</p>
</li>
<li>
<p>set/multiset</p>
<p>set就是集合，set中不允许相同的元素，multiset中则允许存在相同的元素</p>
</li>
<li>
<p>map/multimap</p>
<p>map与set的不同之处在于map中存放的元素有且仅有两个，第一个是first，另一个是second，并且根据first的值来进行排序和检索，multimap中则允许相同的first元素</p>
</li>
<li>
<p>在关联容器前加上 unordered_ 则是非排序（C++ 11中介绍）</p>
</li>
</ul>
</li>
<li>
<p>容器适配器</p>
<ul>
<li>
<p>stack</p>
<p>栈，是项的有限序列，并且满足序列中被删除、检索和修改的项只是最近插入序列的项，后进先出</p>
</li>
<li>
<p>queue</p>
<p>队列，插入只可以在尾部进行，删除、检索和修改只允许从头部进行，先进先出</p>
</li>
<li>
<p>priority_queue</p>
<p>优先队列，最高优先级元素总是第一个出列</p>
</li>
</ul>
</li>
</ul>
<h3 id="93-迭代器">9.3 迭代器</h3>
<ul>
<li>
<p>用于指向顺序容器和关联容器中的元素，用法和指针类似</p>
</li>
<li>
<p>有const和非const两种，通过非const还能修改其指向的元素</p>
</li>
<li>
<p>通过迭代其可以读取它指向的元素</p>
</li>
<li>
<p>迭代器示例</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span><span class="o">&lt;&lt;*</span><span class="n">i</span><span class="o">&lt;&lt;</span><span class="s">&#34;,&#34;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></li>
<li>
<p>双向迭代器</p>
<p>若p和p1都是双向迭代器，则可对p、p1进行如下操作</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">++p, p++</td>
<td style="text-align:left">使p指向容器中的下一个元素</td>
</tr>
<tr>
<td style="text-align:center">&ndash;p, p&ndash;</td>
<td style="text-align:left">使p指向容器中的上一个元素</td>
</tr>
<tr>
<td style="text-align:center">*p</td>
<td style="text-align:left">取p指向的元素</td>
</tr>
<tr>
<td style="text-align:center">p = p1</td>
<td style="text-align:left">赋值</td>
</tr>
<tr>
<td style="text-align:center">p == p1, p != p1</td>
<td style="text-align:left">判断是否相等、不等</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>随机访问迭代器</p>
<p>若p和p1都是随机访问迭代器，则可对p、p1进行以下操作</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">p += i</td>
<td style="text-align:left">将p向后移动i个元素</td>
</tr>
<tr>
<td style="text-align:center">p -= i</td>
<td style="text-align:left">将p向前移动i个元素</td>
</tr>
<tr>
<td style="text-align:center">p + i</td>
<td style="text-align:left">指向p后面的第i个元素的迭代器</td>
</tr>
<tr>
<td style="text-align:center">p - i</td>
<td style="text-align:left">指向p前面的第i个元素的迭代器</td>
</tr>
<tr>
<td style="text-align:center">p[i]</td>
<td style="text-align:left">p后面第i个元素的引用</td>
</tr>
<tr>
<td style="text-align:center">p &lt; p1, p &lt;= p1&hellip;</td>
<td style="text-align:left">比较大小</td>
</tr>
<tr>
<td style="text-align:center">p - p1</td>
<td style="text-align:left">返回p与p1之间的元素个数</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>小总结</p>
<table>
<thead>
<tr>
<th style="text-align:center">容器</th>
<th style="text-align:center">容器上的迭代器类别</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">vector</td>
<td style="text-align:center">随机访问</td>
</tr>
<tr>
<td style="text-align:center">deque</td>
<td style="text-align:center">随机访问</td>
</tr>
<tr>
<td style="text-align:center">list</td>
<td style="text-align:center">双向访问</td>
</tr>
<tr>
<td style="text-align:center">set/multiset</td>
<td style="text-align:center">双向访问</td>
</tr>
<tr>
<td style="text-align:center">map/multimap</td>
<td style="text-align:center">双向访问</td>
</tr>
<tr>
<td style="text-align:center">stack</td>
<td style="text-align:center">不支持迭代器</td>
</tr>
<tr>
<td style="text-align:center">queue</td>
<td style="text-align:center">不支持迭代器</td>
</tr>
<tr>
<td style="text-align:center">priority_queue</td>
<td style="text-align:center">不支持迭代器</td>
</tr>
</tbody>
</table>
<p>注意</p>
<ul>
<li>
<p>有的算法例如sort、binary_search需要通过随机访问迭代器来访问容器中的元素</p>
</li>
<li>
<p>双向迭代器不支持 &lt; ，list里面也没有 <input disabled="" type="checkbox"> 成员函数</p>
</li>
<li>
<p>随机访问迭代器可以通过 v[i] 来访问成员</p>
</li>
</ul>
</li>
</ul>
<h3 id="94-算法">9.4 算法</h3>
<ul>
<li>
<p>两个重要算法</p>
<ul>
<li>
<p>sort 排序</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">sort</span><span class="p">(</span><span class="n">startaddress</span><span class="p">,</span> <span class="n">endaddress</span><span class="p">)</span>

<span class="nl">startaddress</span><span class="p">:</span> <span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">the</span> <span class="n">first</span> <span class="n">element</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span>

<span class="nl">endaddress</span><span class="p">:</span> <span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">the</span> <span class="n">next</span> <span class="n">contiguous</span> <span class="n">location</span> <span class="n">of</span> <span class="n">the</span> <span class="n">last</span> <span class="n">element</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span><span class="p">.</span>

<span class="n">So</span> <span class="n">actually</span> <span class="n">sort</span><span class="p">()</span> <span class="n">sorts</span> <span class="n">in</span> <span class="n">the</span> <span class="n">range</span> <span class="n">of</span> <span class="p">[</span><span class="n">startaddress</span><span class="p">,</span><span class="n">endaddress</span><span class="p">)</span>
</code></pre></div></li>
<li>
<p>binary_search</p>
<p>主要思想是将数组一分为二（分而治之），直到找到元素，或者所有元素都用完为止。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">binary_search</span><span class="p">(</span><span class="n">startaddress</span><span class="p">,</span> 
          <span class="n">endaddress</span><span class="p">,</span> <span class="n">valuetofind</span><span class="p">)</span>
<span class="nl">Parameters</span> <span class="p">:</span>
<span class="nl">startaddress</span><span class="p">:</span> <span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">the</span> <span class="n">first</span> 
              <span class="n">element</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span><span class="p">.</span>
<span class="nl">endaddress</span><span class="p">:</span> <span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">the</span> <span class="n">next</span> <span class="n">contiguous</span> 
            <span class="n">location</span> <span class="n">of</span> <span class="n">the</span> <span class="n">last</span> <span class="n">element</span> <span class="n">of</span> <span class="n">the</span> <span class="n">array</span><span class="p">.</span>
<span class="nl">valuetofind</span><span class="p">:</span> <span class="n">the</span> <span class="n">target</span> <span class="n">value</span> <span class="n">which</span> <span class="n">we</span> <span class="n">have</span> 
             <span class="n">to</span> <span class="n">search</span> <span class="k">for</span><span class="p">.</span>
<span class="nl">Returns</span> <span class="p">:</span>
<span class="nb">true</span> <span class="k">if</span> <span class="n">an</span> <span class="n">element</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">valuetofind</span> <span class="n">is</span> <span class="n">found</span><span class="p">,</span> <span class="k">else</span> <span class="nb">false</span><span class="p">.</span>
</code></pre></div></li>
</ul>
</li>
<li>
<p>顺序容器和关联容器中皆有的函数成员</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">begin</td>
<td style="text-align:left">返回指向容器中第一个元素的迭代器</td>
</tr>
<tr>
<td style="text-align:center">end</td>
<td style="text-align:left">返回指向容器中最后一个元素后面位置的迭代器</td>
</tr>
<tr>
<td style="text-align:center">rbegin</td>
<td style="text-align:left">返回指向容器中最后一个元素的迭代器</td>
</tr>
<tr>
<td style="text-align:center">rend</td>
<td style="text-align:left">返回指向容器中第一个元素前面的位置的迭代器</td>
</tr>
<tr>
<td style="text-align:center">insert</td>
<td style="text-align:left">向容器中插入某个（些）元素</td>
</tr>
<tr>
<td style="text-align:center">find</td>
<td style="text-align:left">查找等于某个值的元素</td>
</tr>
<tr>
<td style="text-align:center">erase</td>
<td style="text-align:left">从容器中删除一个或者几个元素</td>
</tr>
<tr>
<td style="text-align:center">clear</td>
<td style="text-align:left">从容器中删除所有元素</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>顺序容器的常用成员函数</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">front</td>
<td style="text-align:left">返回容器中第一个元素的引用</td>
</tr>
<tr>
<td style="text-align:center">back</td>
<td style="text-align:left">返回容器中最后一个元素的引用</td>
</tr>
<tr>
<td style="text-align:center">push_back</td>
<td style="text-align:left">在容器末尾增加新的元素</td>
</tr>
<tr>
<td style="text-align:center">pop_back</td>
<td style="text-align:left">删除容器末尾的元素</td>
</tr>
<tr>
<td style="text-align:center">erase</td>
<td style="text-align:left">删除迭代器指向的元素（可能会使其失效），或者删除一个区间，返回被删除元素后面的元素的迭代器</td>
</tr>
</tbody>
</table>
<p>注意：List除了顺序容器的所有成员函数以外还支持以下8种函数：</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">push_front</td>
<td style="text-align:left">在前面插入</td>
</tr>
<tr>
<td style="text-align:center">pop_front</td>
<td style="text-align:left">删除前面的元素</td>
</tr>
<tr>
<td style="text-align:center">sort</td>
<td style="text-align:left">排序，list 不支持 STL 的排序</td>
</tr>
<tr>
<td style="text-align:center">remove</td>
<td style="text-align:left">删除和指定值相等的所有元素</td>
</tr>
<tr>
<td style="text-align:center">unique</td>
<td style="text-align:left">删除所有和前一个元素相同的元素</td>
</tr>
<tr>
<td style="text-align:center">merge</td>
<td style="text-align:left">合并两个列表，并且清空被合并的辣个</td>
</tr>
<tr>
<td style="text-align:center">reverse</td>
<td style="text-align:left">颠倒列表</td>
</tr>
<tr>
<td style="text-align:center">splice</td>
<td style="text-align:left">在指定位置插入另一个链表的一个或多个元素，并在另一个链表中删除被插入的元素</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>关联容器的常用成员函数</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名称</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">upper_bound</td>
<td style="text-align:left">查找上界</td>
</tr>
<tr>
<td style="text-align:center">lower_bound</td>
<td style="text-align:left">查找下界</td>
</tr>
<tr>
<td style="text-align:center">equal_range</td>
<td style="text-align:left">同时查找上下界</td>
</tr>
<tr>
<td style="text-align:center">count</td>
<td style="text-align:left">计算等于某个值的元素个数</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="更多内容参考httpswwwgeeksforgeeksorgalgorithms-library-c-stl">更多内容参考：https://www.geeksforgeeks.org/algorithms-library-c-stl/</h4>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/figma-%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/">
        
        

        <div class="article-details">
            <h2 class="article-title">Figma 简单教程</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
     
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (DISQUS) {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2021 wPv的个人小站
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.2.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">Table of contents</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#目录">目录</a></li>
    <li><a href="#span-id11-字符串与指针span"><!-- raw HTML omitted -->1 字符串与指针<!-- raw HTML omitted --></a>
      <ol>
        <li><a href="#11-处理字符与字符串">1.1 处理字符与字符串</a></li>
        <li><a href="#12-标准c的string类">1.2 标准C++的String类</a></li>
        <li><a href="#13-指针的概念指针变量的定义和使用">1.3 指针的概念、指针变量的定义和使用</a></li>
        <li><a href="#14-指针与数组">1.4 指针与数组</a></li>
      </ol>
    </li>
    <li><a href="#span-id22-指针与函数span"><!-- raw HTML omitted -->2 指针与函数<!-- raw HTML omitted --></a>
      <ol>
        <li><a href="#21-参数的传递方式">2.1 参数的传递方式</a></li>
        <li><a href="#22-返回指针的函数及指向函数的指针">2.2 返回指针的函数及指向函数的指针</a></li>
        <li><a href="#23-指针数组与指向指针的指针">2.3 指针数组与指向指针的指针</a></li>
        <li><a href="#24-内存的动态分配与释放">2.4 内存的动态分配与释放</a></li>
        <li><a href="#25-void-和-const-修饰指针变量">2.5 void 和 const 修饰指针变量</a>
          <ol>
            <li><a href="#251-void修饰指针变量">2.5.1 void修饰指针变量</a></li>
            <li><a href="#252-const修饰指针变量">2.5.2 const修饰指针变量</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#span-id33-结构体与列表span"><!-- raw HTML omitted -->3 结构体与列表<!-- raw HTML omitted --></a>
      <ol>
        <li><a href="#31-结构体的建立">3.1 结构体的建立</a></li>
        <li><a href="#32-结构体的应用">3.2 结构体的应用</a></li>
        <li><a href="#33-typedef-定义类型名">3.3 typedef 定义类型名</a></li>
        <li><a href="#34-链表">3.4 链表</a></li>
      </ol>
    </li>
    <li><a href="#span-id44-文件操作span"><!-- raw HTML omitted -->4 文件操作<!-- raw HTML omitted --></a>
      <ol>
        <li><a href="#41-文件的打开与关闭">4.1 文件的打开与关闭</a>
          <ol>
            <li><a href="#打开文件"><strong>打开文件</strong></a></li>
            <li><a href="#关闭文件"><strong>关闭文件</strong></a></li>
          </ol>
        </li>
        <li><a href="#42-文本文件输入输出">4.2 文本文件输入输出</a>
          <ol>
            <li><a href="#getline成员函数"><strong>getline</strong>成员函数：</a></li>
            <li><a href="#get成员函数">get成员函数</a></li>
            <li><a href="#put成员函数">put成员函数</a></li>
          </ol>
        </li>
        <li><a href="#43-文件出错检测方法">4.3 文件出错检测方法</a>
          <ol>
            <li><a href="#流对象的标志位">流对象的标志位</a></li>
          </ol>
        </li>
        <li><a href="#44-多文件操作">4.4 多文件操作</a></li>
        <li><a href="#45-操作简单二进制文件">4.5 操作简单二进制文件</a>
          <ol>
            <li><a href="#以二进制打开文件">以二进制打开文件</a></li>
            <li><a href="#二进制文件的读写函数仅如下两个">二进制文件的读写函数（仅如下两个）、</a></li>
          </ol>
        </li>
        <li><a href="#46-读写结构体文件">4.6 读写结构体文件</a></li>
        <li><a href="#47-随机访问文件">4.7 随机访问文件</a></li>
      </ol>
    </li>
    <li><a href="#span-id55-类的基础部分span"><!-- raw HTML omitted -->5 类的基础部分<!-- raw HTML omitted --></a>
      <ol>
        <li><a href="#51-类的基本概念">5.1 类的基本概念</a>
          <ol>
            <li><a href="#数据类型">数据类型</a></li>
            <li><a href="#方式一在类内部定义">方式一、在类内部定义</a></li>
            <li><a href="#方式二在类的外部定义">方式二、在类的外部定义</a></li>
            <li><a href="#实例">实例</a></li>
          </ol>
        </li>
        <li><a href="#52-类的多文件组织方式">5.2 类的多文件组织方式</a></li>
        <li><a href="#53-构造函数与析构函数">5.3 构造函数与析构函数</a>
          <ol>
            <li><a href="#指向对象的指针">指向对象的指针</a></li>
          </ol>
        </li>
        <li><a href="#54-重载构造函数">5.4 重载构造函数</a>
          <ol>
            <li><a href="#特点">特点</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#span-id66-类的高级部分span"><!-- raw HTML omitted -->6 类的高级部分<!-- raw HTML omitted --></a>
      <ol>
        <li><a href="#61-静态数据成员">6.1 静态数据成员</a>
          <ol>
            <li><a href="#特点-1">特点</a></li>
          </ol>
        </li>
        <li><a href="#62-静态成员函数">6.2 静态成员函数</a>
          <ol>
            <li><a href="#特点-2">特点</a></li>
          </ol>
        </li>
        <li><a href="#63-友元函数">6.3 友元函数</a>
          <ol>
            <li><a href="#特点-3">特点</a></li>
            <li><a href="#声明方式">声明方式</a></li>
          </ol>
        </li>
        <li><a href="#64-对象的赋值问题">6.4 对象的赋值问题</a></li>
        <li><a href="#65-什么是拷贝构造函数">6.5 什么是拷贝构造函数</a></li>
        <li><a href="#66-调用拷贝构造函数的情况">6.6 调用拷贝构造函数的情况</a></li>
        <li><a href="#67-赋值运算符重载与this指针">6.7 赋值运算符重载与this指针</a></li>
        <li><a href="#68-双目运算符重载">6.8 双目运算符重载</a></li>
        <li><a href="#69-单目运算符重载">6.9 单目运算符重载</a></li>
        <li><a href="#610-关系运算符重载">6.10 关系运算符重载</a></li>
        <li><a href="#611-流操作符重载">6.11 流操作符重载</a></li>
        <li><a href="#612-类型转换运算符重载">6.12 类型转换运算符重载</a></li>
        <li><a href="#span-id613613-下标运算符重载span"><!-- raw HTML omitted -->6.13 下标运算符[]重载<!-- raw HTML omitted --></a></li>
        <li><a href="#注意运算符重载不能改变运算符原来要求的参数个数">注意：运算符重载不能改变运算符原来要求的参数个数。</a></li>
      </ol>
    </li>
    <li><a href="#span-id77-类的继承多态虚函数span"><!-- raw HTML omitted -->7 类的继承、多态、虚函数<!-- raw HTML omitted --></a>
      <ol>
        <li><a href="#71-继承">7.1 继承</a></li>
        <li><a href="#72-保护成员和类的访问">7.2 保护成员和类的访问</a></li>
        <li><a href="#73-保护成员和类的访问">7.3 保护成员和类的访问</a></li>
        <li><a href="#74-初始化列表的作用">7.4 初始化列表的作用</a></li>
        <li><a href="#75-覆盖基类的函数成员">7.5 覆盖基类的函数成员</a></li>
        <li><a href="#76-虚函数与纯虚函数">7.6 虚函数与纯虚函数</a></li>
        <li><a href="#77-多重继承与多继承">7.7 多重继承与多继承</a></li>
        <li><a href="#78-类模板">7.8 类模板</a></li>
      </ol>
    </li>
    <li><a href="#span-id88-异常处理span"><!-- raw HTML omitted -->8 异常处理<!-- raw HTML omitted --></a></li>
    <li><a href="#span-id99-标准模板stlspan"><!-- raw HTML omitted -->9 标准模板STL<!-- raw HTML omitted --></a>
      <ol>
        <li><a href="#91-stl-概述">9.1 STL 概述</a></li>
        <li><a href="#92-容器">9.2 容器</a></li>
        <li><a href="#93-迭代器">9.3 迭代器</a></li>
        <li><a href="#94-算法">9.4 算法</a>
          <ol>
            <li><a href="#更多内容参考httpswwwgeeksforgeeksorgalgorithms-library-c-stl">更多内容参考：https://www.geeksforgeeks.org/algorithms-library-c-stl/</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
